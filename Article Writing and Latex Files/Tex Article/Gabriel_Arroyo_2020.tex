\documentclass[citeauthoryear]{llncs}
\newcommand{\keywords}[1]{\textbf{Keywords:}\quad #1}
\usepackage{cite}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{subfigure}

%Packages and settings to run the algorithms properly 
\usepackage[ruled]{algorithm2e}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

%Adds the possibility to Create Sub-Sub-Sections
\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}


%\graphicspath{ {images/} }
\renewcommand{\tabcolsep}{3mm}

\title{Heurísticas para Agendamento de Produção de uma Máquina Linear e Roteamento de Entrega com Frota Heterogênea de Veículos
}
\author{Gabriel de P. Felix  \and José E. C. Arroyo \ }
\institute{Department of Computer Science, Universidade Federal de Viçosa,\\ Vi\c{c}osa - MG, 36570-900, Brazil\\
gabriel.felix@ufv.br,  jarroyo@dpi.ufv.br}


\begin{document}

\maketitle
\begin{abstract}
Este artigo aborda um problema de programação multiobjetivo do sequenciamento de produção de uma máquina linear integrado ao roteamento de veículos para entrega. Nesta abordagem as tarefas possuem penalidades de atraso, datas de vencimento e são caracterizadas por diferentes volumes, com uma frota heterogênea e limitada de veículos (HFVRP). Os critérios a serem minimizados são referentes ao atraso total ponderado e também aos custos de transporte e entrega, incluindo rotas escolhidas e veículos utilizados. 

O problema é classificado como NP-Difícil no senso comum, portanto heurísticas eficientes são necessárias para obter soluções próximas da ótima em tempo computacional razoável.
Neste trabalho são propostas duas heurísticas baseadas em Iterated Local Search e um Algoritmo Genético (AG). Instâncias para o problema são geradas com base em trabalhos anteriores e os resultados obtidos são comparados aos do solver de otimização CPLEX. Os resultados mostram que as heurísticas aplicadas possuem performance em tempo e qualidade superior às soluções do software a medida em que o número de clientes aumenta.


\keywords{Single machine scheduling, vehicle routing, heterogeneous fleet, time windows, linear programming, meta-heuristics.}
\end{abstract}

\section{Introdução}\label{introduction}

O processo de agendamento de produção e roteamento de veículos é uma tarefa que está presente em manufaturas, e possui grande importância econômica por conta dos prazos impostos, custos de entrega e manuseio do tempo gasto. Separadamente, o problema de agendamento em uma máquina linear com minimização do atraso total é provado como NP-Difícil (Du and Leung, 1990)\cite{du1990}. 

Este trabalho teve por objetivo uma representação realista da integração entre o processo de agendamento de produção de uma máquina linear e roteamento de veículos, com tarefas de diferentes volumes e uma frota heterogênea limitada de veículos, i.e., possuem capacidades e custos variados. 

As aplicações para este problema possuem grande abrangência de setores industriais (como o setor quimico, metalúrgico e têxtil), e a crescente pressão nos mercados globais força as empresas à manusearem seus recursos de forma adequada para garantir um bom funcionamento. 

Nas últimas décadas, o problema do estudo de roteamento de veículos tornou-se uma questão de foco na literatura acadêmica (Braekers, Ramaekers e Van Nieuwenhuyse, 2016)\cite{braekers2016vehicle}. Neste artigo, por tratar uma frota de veículos heterogênea e limitada, é apresentada uma desafiadora manutenção dos recursos disponíveis, o que torna imprescindível a realização de uma boa gestão.

Pelo conhecimento dos autores deste artigo, o problema integrado de sequenciamento em uma máquina simples e roteamento com veículos de capacidades e custos variáveis,  tarefas de diferentes tamanhos, e  com o objetivo de minimizar o atraso ponderado total e custos de entrega, ainda não foi abordado na literatura. São componentes deste trabalho:

\begin{itemize}
  \item Duas abordagens heurísticas de Iterated Local Search (ILS) e um Algoritmo Genético (G.A.).
  \item Um modelo de programação linear para solução dos problemas integrados.
\end{itemize}
Na Seção \ref{lit-review} são apresentados estudos prévios na literatura, e na Seção \ref{problemdescription} a descrição do problema tratado neste artigo. Em seguida, nas Seções \ref{solutionrepresentation} e \ref{hipcase} são retratadas a representação de solução escolhida e um caso hipotético do problema, respectivamente. Acompanha esta última um modelo matemático misto de programação linear na Seção \ref{mathematicalmodel}. Na Seção \ref{instancesgen} são descritos parâmetros e restrições utilizadas na geração de instâncias.

Continua...
%Continuar a escrever!..

\section{Revisão Literária}\label{lit-review}

São descritos nesta seção estudos prévios realizados em problemas de Agendamento de Produção, Roteamentos de Veículos e a combinação destes dois.

%Inserir aqui VRP e HFRP
M. Gendreau, G. Laporte and C. Musaragayi (1999)\cite{gendreau1999tabu} propuseram um algoritmo Tabu Search para o problema de Roteamento de Veículos com Frota Heterogênea (HVRP), e foram obtidas soluções de boa qualidade para as instâncias abordadas.
Christian Ullrich (2013) \cite{ullrich2013} desenvolveu um Algoritmo Genético (A.G.) integrando agendamento de produção de máquinas paralelas e roteamento de uma frota heterogênea, em um ambiente com janelas de tempo de entrega e veículos com diferentes capacidades.

%inserir aqui os problemas de agendamento
Hall and Potts (2003) \cite{hall2003supply} abordaram o problema integrado de agendamento de produção e entre de lotes, com vários clientes e manufaturas, e definiram assim a área de Supply Chain Scheduling.
Kirlik and Oguz (2012) \cite{kirlik2012variable} desenvolveram um General Variable Neighborhood Search (GVNS) para resolver o problema de Minimização do Atraso Total Ponderado com tempos de configuração dependentes da sequência.

%Inserir aqui a combinação dos dois problemas
Estudos são realizados na área de pesquisa operacional para integrar os dois problemas.
Condotta, Knust, Meier, and Shakhlevich (2013)\cite{condotta2013tabu} estudaram o problema de minimizar o atraso máximo de uma máquina linear e considerando datas de entrega para os trabalhos, com veículos com mesma capacidade para entrar as tarefas.
Há pouco tempo, Hassanzadeh and RastiBarzoki (2017)\cite{hassanzadeh2017} estudaram a otimização na cadeia de produção considerando o problema de roteamento de veículos com penalidades de atraso e consumo total de recursos.

Tamannaei and Morteza (2019)\cite{tamannaei2019} desenvolveram o primeiro modelo matemático misto de programação linear para o problema de minimização do atraso ponderado total e custos de entrega. Foram propostos três algoritmos genéticos (A.G.) e um método exato  Branch-and-Bound (B\&B).




\section{Descrição do Problema}\label{problemdescription}

Nesta seção, o problema discutido neste artigo é apresentado juntamente ao seus parâmetros, índices, variáveis de decisão. Em seguida, a função multiobjetivo tratada no problema é descrita em partes.

\begin{tabbing}
\phantom{$D_{n100}\ $}\= \kill
\textbf{Indices:} \\
\\
$i,j$\>  Index of jobs.\\
$k$\>  Index of vehicles.\\
$K$\>  Number of vehicles.\\
$N$\>  Number of jobs.\\
\\
\textbf{Instance Parameters:}\\
\\
$Q_{k}$\>  Capacity of each vehicle $k$.\\
$F_{k}$\>  Cost of each vehicle $k$.\\
$P_{i}$\>  Processing time associated to job $i$.\\
$t_{ij}$\>  Travel time between customer of job $i$ and customer of job $j$.\\
$w_{i}$\> Penalty applied to delivery tardiness of job i.\\
$s_{i}$\>  Size of job $i$.\\
$d_{i}$\>  Due date associated to job $i$.\\
\\
\textbf{Decision Variables:}\\
\\
$C_{i}$\>  Completion time of job $i$\\
$X^{k}_{ij}$\>  Binary decision variable which indicates with value '1' that a vehicle {k}\\\> 
                went from customer of job $i$ to customer of job $j$, and '0' otherwise.\\
$Y_{k}$\>  Binary variable which represents with value '1' if a vehicle $k$ is used,\\\>
            and '0' otherwise.\\
$S_{k}$\>  Time of a vehicle $k$ starts to be used.\\
$A_{ij}$\>  Binary variable which represents if a job $i$ is processed before job $j$,\\
\> value '1' if it's true, and '0' otherwise.\\
$D_{i}$\>  Delivery time of job $i$.\\
$T_{i}$\>  Tardiness of job $i$.\\
\end{tabbing}

Seja uma máquina linear que lidará com $N$ tarefas, isto é, cada tarefa $i$ de tamanho $s_i$ deverá ser processada em sequência a partir do início do processo ($t=0$). Um cliente ordena somente uma tarefa. Caso uma tarefa $i$ seja processada antes de uma tarefa $j$ na máquina, a variável $A_ij$ possuirá valor ‘1’, ou ‘0’ caso contrário.  O tempo de completude de processamento para tarefa $i$ é representado por $C_i$. 
Para a entrega das tarefas, são disponibilizados $K$ veículos, realizando circuitos partindo da origem ‘O’,  sendo a distância entre dois clientes $i$ e $j$ representada por $t_ij$. Na rota percorrida para entrega, caso uma tarefa $i$ seja entregue imediatamente anterior à uma tarefa $j$ e seja entregue por um veículo $k$, esta será representada pela variável $X^{k}_{ij}$ com valor ‘1’, ou ‘0’ caso contrário. A distância de trajeto entre dois clientes $i$ e $j$ é representada por $t_{ij}$. Este conjunto de variáveis combinadas descreve a primeira parte da função objetivo, que minimiza o a distância de entrega percorrida pelos veículos:
\begin{equation}
    \label{eq:objone}
    \min \sum_{i,j=0}^N\sum_{k=0}^K X^{k}_{ij}*t_{ij}  
\end{equation}

Cada veículo $k$ possui capacidade $Q_k$ e custo de utilização $F_k$, além de possuir tempo de ínicio $S_k$. Caso um veículo $k$ seja utilizado, será representado em $Y_k$ com o valor ‘1’, ou ‘0’ caso contrário. Dessa forma, a segunda parte da função objetivo é representada pela minimização dos custos dos veículos:
\begin{equation}
    \label{eq:objtwo}
    \min \sum_{k=0}^K F_{k}*Y_{k}
\end{equation}
Cada tarefa $i$  possui tempo de processamento $P_i$ e data de vencimento $d_i$ vinculada, que pode ser penalizada por uma constante $w_i$ multiplicada pelo seu atraso $T_i$. O tempo de chegada no destinatário é representado por $D_i$.
A variável de atraso $T$ é dada por $D_i-d_i$, i.e., a diferença entre o tempo de chegada e a data de vencimento. Dessa forma, $T_i$ = max(0, $D_i-d_i$) e a terceira parte da função objetivo é a minimização do atraso total ponderado das entregas:
  
\begin{equation}
    \label{eq:objthree}
    \min \sum_{i=1}^N w_{i}*T_{i}
\end{equation}

Os problemas de minimização descritos acima tratam partes específicas do processo de produção ou entrega de uma manufatura. Finalmente, ao somar os três problemas de minimização, é gerado o problema tratado neste artigo, que representa a minimização dos custos de entrega e seu atraso total ponderado:

\begin{equation}
    \label{eq:objfull}
    \min \sum_{i,j=0}^N\sum_{k=0}^K X^{k}_{ij}*t_{ij}  
    + \sum_{k=0}^K F_{k}*Y_{k} + \sum_{i=1}^N w_{i}*T_{i}
\end{equation}

Quando não tratado o Problema de Minimização de Atraso, resta o Problema de Roteamento com Frota Heterogênea de Veículos (HFVRP), uma versão de VRP, que separadamente é strong NP-Hard (Chen,2010)\cite{chen2010integrated}.  Por consequência, o problema descrito é também de complexidade strong NP-Hard.

\section{Mathematical Model}\label{mathematicalmodel}

Nesta seção, um modelo matemático linear misto é apresentado. Este é modelo é uma versão modificada do proposto por (Tamannaei and Rasti-Barzoki, 2019)\cite{tamannaei2019}, sendo o primeiro desenvolvido na versão do problema em que veículos possuem mesma capacidades ($Q$) e custos ($F$). O modelo é descrito a seguir:

\setcounter{equation}{0}
\begin{equation}
    \label{mm:obj}
    \min \sum_{i,j=0}^N\sum_{k=0}^K X^{k}_{ij}*t_{ij}  
    + \sum_{k=0}^K F_{k}*Y_{k} + \sum_{i=1}^N w_{i}*T_{i}
\end{equation}
st.

    \begin{equation}
        \label{mm:come-out-1-time}
        \sum_{k=0}^K\sum_{j=0,j\neq i}^N X^{k}_{ij} = 1, \quad \forall i = 1 \dots N\\
    \end{equation}
    
    \begin{equation}
        \label{mm:capacity}
        \sum_{i=0}^N \sum_{j=0, j\neq i}^N {s_{i} *X^{k}_{ij} } \leq Q_{k}*Y_{k},  \quad \forall k = 0 \dots K;  
	\end{equation}%
	\begin{equation}
        \label{mm:vehicle-use}
        \sum_{j=0}^N X^{k}_{0j} = Y_{k}, \quad  \forall k = 0 \dots K;\\
    \end{equation}
    	\begin{equation}
        \label{mm:come-in-and-out}
        \sum_{i=0}^N X^{k}_{ih} = \sum_{j=0}^N X^{k}_{hj}; \quad \forall h = 0 \dots N;\\ \forall k = 0 \dots K\\
    \end{equation}
     \begin{equation}
        \label{mm:proc-order-1}
        A_{ij}+A_{ji}=1; \quad  \forall i,j = 0 \dots N; i\neq j;
    \end{equation}
    
    \begin{equation}
        \label{mm:proc-order-2}
        A_{ij}+A_{jr}+A_{ri} \geq 1; \quad \forall i,j,r= 0 \dots N; i\neq j\neq r;\\
    \end{equation}
    
     \begin{equation}
        \label{mm:comp-time}
        C_{j} = \sum_{i=1,i\neq j}^N (P_{i}*A_{ij}) + P_{j};
        \quad \forall j=1 \dots N;    
    \end{equation}
    
    \begin{equation}
        \label{mm:big-m}
        S_{k}\geq C_{j} - M*(1- \sum_{i=1,i\neq j}^N X^{k}_{ij});
        \quad \forall j=1 \dots N; \forall k=0 \dots K;
    \end{equation}
    
    \begin{equation}
        \label{mm:big-m-2}
        D_{j}-S_{k} \geq t_{0j} - M*(1 - X^{k}_{0j}); \quad \forall k=0 \dots K; \forall j=1 \dots N
    \end{equation}
     \begin{equation}
        \label{mm:big-m-3}
        D_{j}-D_{i} \geq t_{ij} - M*(1 -\sum_{i=1}^N X^{k}_{ij}); \quad \forall i,j=1 \dots N;
    \end{equation}
    
     \begin{equation}
        \label{mm:tardiness}
        T_{i} \geq D_{i}-d_{i}; \quad \forall i=1 \dots N;
    \end{equation}
    
    \begin{equation}
        \label{mm:comp-time-origin}
        C_{0}=0;
    \end{equation}
    
    \begin{equation}
        \label{mm:dest-time-origin}
        D_{0}= 0;
    \end{equation}
    
     \begin{equation}
        \label{mm:tardiness-origin}
        T_{0}= 0;
    \end{equation}
    \begin{equation}
        \label{mm:xijk-binary}
        X_{ijk}\in \{0,1\};  \quad \forall i,j=0 \dots N, \forall k=0 \dots K;
    \end{equation}
    \begin{equation}
        \label{mm:aij-binary}
        A_{ij}\in\{0,1\};  \quad \forall i,j=1 \dots N;
    \end{equation}
    \begin{equation}
        \label{mm:yk-binary}
        Y_{k}\in\{0,1\};  \quad \forall k=0 \dots N;
    \end{equation}
    \begin{equation}
        \label{mm:sk-geq-zero}
        S_{k}\geq 0;  \quad  \forall k=0 \dots K;
    \end{equation}
     \begin{equation}
        \label{mm:tardiness-geq-zero}
        T_{i}\geq 0;  \quad  \forall i=1 \dots N;
    \end{equation}
    \begin{equation}
        \label{mm:dest-time-geq-zero}
        D_{i}\geq 0;  \quad \forall i=1 \dots N;
    \end{equation}

The objective function (\ref{mm:obj}) is to minimize the travel distance, total tardiness weight of the jobs and the used vehicles costs. Constraints (\ref{mm:come-out-1-time}) ensure that each job is carried by exactly one vehicle.

Constraints (\ref{mm:capacity}) guarantee that sum of jobs in each vehicle doesn't  overcome it's capacity. Constraints (\ref{mm:vehicle-use}) indicates that if a vehicle is in use, it will leave the origin.

Constraints (\ref{mm:come-in-and-out}) ensure that if a vehicle arrives at a customer, it will also leave  that customer. Constraints (\ref{mm:proc-order-1}) and (\ref{mm:proc-order-2}) are to maintenance the processing order, demanding jobs to be processed in a sequential and possible order.

Constraints (\ref{mm:comp-time}) defines the completion time of a job as the sum of previous jobs' processing times and its own. Constraints (\ref{mm:big-m}) guarantee that if a job $j$ is carried by a vehicle $k$, the vehicle start time will be greather than job $j$'s completion time. 

% Help in Constraints 10 and 1
Constraints (\ref{mm:big-m-2}) indicates that if a job $j$ is carried by a vehicle $k$ is the first of its tour, its destination time $D_j$ is greater or equal than the sum of start vehicle time $S_k$ and distance between origin and this customer  Constraints (\ref{mm:big-m-3}) certify that if a job $j$ delivered by a vehicle $k$ isn't the first of its tour, its delivery time will be greater or equal than the sum of the previous job $i$ delivery time $D_i$ and the start vehicle time $S_k$.

Constraints (\ref{mm:tardiness}) defines the tardiness T of a job as the difference between its destination time (D) and its due date (d).   Constraints (\ref{mm:comp-time-origin}), (\ref{mm:dest-time-origin}) and (\ref{mm:tardiness-origin}) certifies that the origin (customer zero) do not assume any impossible values. 

Constraints (\ref{mm:xijk-binary}), (\ref{mm:aij-binary}) and (\ref{mm:yk-binary}) are to define these variables as binary variables. Constraints (\ref{mm:sk-geq-zero}), (\ref{mm:tardiness-geq-zero}) and (\ref{mm:dest-time-geq-zero}) ensure that these variables won't assume negative values.


\section{Geração de Instâncias}\label{instancesgen}

Por se tratar de uma variação do problema ainda não abordada na literatura, a criação de instâncias para o problema tornou-se necessária. As instâncias foram distruibuídas em dois grupos, instâncias pequenas e grandes. O primeiro varia entre oito e vinte tarefas, de três à seis veículos, e o segundo entre trinta e cem tarefas, de cinco à doze veículos.

Seja uma tarefa $i$ $\in$ $N$, seu tempo de processamento $P_{i}$ pertence um intervalo limitado:

\setcounter{equation}{0}
\begin{equation} 
\label{ins-P}
P_{i} \in rand[1,\rho], \quad with \quad \rho = 100
\end{equation}

Seu tamanho $s_i$  é relacionado ao tempo de processamento, também definido em um intervalo:

\begin{equation}
\label{ins-s}
s_{i} \in rand[1,P_{i}]
\end{equation}

A data de vencimento $d_i$ de uma tarefa deve possuir ligação entre seu tempo de processamento e a distância entre o cliente e a origem. Ela é determinada a partir de uma janela de tempo, que possui limite inferior $z_i$ e superior $\overline{z}_{i}$:
\begin{equation}
\label{ins-d}
 \begin{array}{l}
    d_{i} \in rand[z_{i},\overline{z}_{i}] \quad st. \\
    \begin{array}{l}
    				z_i = P_{i}+t_{0i}+\pi_1 \\
     			\quad \overline{z}_{i} = z_{i} + \pi_2\\
   			  \end{array}
 \end{array}
\end{equation}

Os parâmetros $\pi_1$ e $\pi_2$ influenciam na dificuldade da instância pois seus valores podem encurtar ou prolongar as janelas de tempo, resultando em prazos de entrega menores ou maiores:
\begin{equation}
\label{ins-pi}
 \begin{array}{l}
 	\pi_1 \in rand[0,\frac{\sum_{i=1}^N P_{i}}{K+1}]\\
 	\pi_2 \in rand[0,\delta*\rho]
 \end{array}
\end{equation}

O peso de penalidade $w_i$ é determinado de forma aleatória em um intervalo, sendo este parâmetro integrante da função objetivo:
\begin{equation}
\label{ins-w}
 w_{i} \in rand[1.0, 5.0]
\end{equation}
 A capacidade $Q$ dos veículos é dada de forma que a tarefa de maior tamanho possa ser transportada qualquer um destes, somado à um valor relacionado a média de todos tamanhos pela quantidade de veículos:
 
\begin{equation}
\label{ins-Q}
	\begin{array}{l}
    		Q_{k} = max_{i=1}^N\{s_{i}\} + \tau \quad st.\\
  		\tau \in rand[{\frac{\sum_{i=1}^N s_{i}}{K}},\mu*{\frac{\sum_{i=1}^N s_{i}}{K}}]\\ 
	\end{array}
\end{equation}

O custo $F_k$ de um veículo $k$ é diretamente proporcional à sua capacidade:
\begin{equation}
\label{ins-Q}
    F_{k} = N*Q_{k}
\end{equation}
    
   
To determine the travel time $t_{ij}$ between two customers, first we have to generate the origin's coordinates.
The machine's coordinates $(x_0,y_0)$ are generated subject to the following range:\\ 
\begin{equation}
\label{ins-origin}
x_{0},y_{0} \in  rand[400,700]
\end{equation}
Após fixadas as coordenadas da origem. são geradas as coordenadas dos clientes de forma que estejam no primeiro quadrante e sua distância euclidiana (ED) até a origem respeite a seguinte constante:
\begin{equation}
\label{ins-customers}
\begin{array}{l}
    (x_{i},y_{i}) \geq (0,0) \quad \forall i=1,...,N\\
    ED((x_0,y_0), (x_i,y_i)) \leq (\rho * K) \quad \forall i=1,...,N
\end{array}
\end{equation}

Por fim, são indicados os parâmetros utilizados nas equações acima ($\delta$,$\mu$, $N$ and $K$). Para cada um dos conjuntos de instâncias (small e large), existe uma definição diferente dos valores dos parâmetros, que influenciará na dificuldade da resolução do problema. 

Para instâncias pequenas, os valores definidos para $\mu$, $N$ and $K$ são:
\begin{equation}
\label{ins-small-parameters}
	\begin{array}{ll}
		\mu \in \{1, 1.5, 2.0\}\\
		N \in \{8,10,15,20\}\\
		K \in \{3,4,5, 6\}\\
	\end{array}
\end{equation}

Para instâncias maiores, após realizados os ajustes dos três parâmetros, estes foram definidos em:
\begin{equation}
\label{ins-large-parameters}
	\begin{array}{lll}
		\mu \in \{1.5, 2.0, 2.5\}\\
		N \in \{50,80,100\}\\
		K \in \{5,8,10,12\}\\
	\end{array}
\end{equation}
A constante $\delta$ utilizada para calcular o limite superior de $d_i$ (Equação \ref{ins-pi}), assume os seguintes valores para ambos conjuntos de instâncias:
\begin{equation}
	\delta \in \{0.5, 1.0, 1.5, 2.0, 2.5\}
\end{equation}

Definidos os parâmetros, para cada combinação ($\delta$,$\mu$, $N$ and $K$) foram geradas cinco instâncias pequenas e três instâncias grandes, totalizando (5*3*4*4*5) + (3*3*3*4*5) = 1740 instâncias.

\section{Representação de Solução}\label{solutionrepresentation}


A representação de uma solução é disposta linearmente, de modo que tarefas e veículos sigam acompanhados de seus respectivos códigos de identificação. O conjunto de tarefas $N$ do problema será dividido em $K$ subconjuntos, sendo cada subconjunto destinado à um veículo específico. O tempo de ínicio de funcionamento de um veículo $k$, denotado por $S_k$, é dado pela soma dos tempos de processamento $P$ destas tarefas somado ao tempo acumulado das tarefas processadas anteriormente (a partir de $t=0$).
Em cada subconjunto há definição de uma rota, que indica o trajeto percorrido por um veículo. Seja $R$ uma solução viável, $k$ $\in$ $K$ um veículo e $R_k$ sua rota, a representação deste trajeto é dada por:

\begin{equation}
R_{k} = O \rightarrow  J_1\rightarrow  J_2\rightarrow ... \rightarrow  J_{|N_{k}|}\rightarrow  O
\end{equation}

Neste contexto, $Ji$ são as tarefas entregues no trajeto e $\forall i=1, ... |N_k|$ $\in$ $N$  e $|N_k|$ a quantidade de tarefas dispostas neste veículo. Todo veículo parte da origem, e deve retornar para ela, visitando cada cliente somente uma vez. A Figura \ref{fig:solutionrep} representa visualmente uma solução.

\begin{figure}[ht]
	\centering
    \includegraphics[width=1\textwidth]{Images/SOL_REP2} 
    \caption[]{Representação de solução com tarefas organizadas em lotes.}
  	\label{fig:solutionrep}
\end{figure}

Um subconjunto de tarefas pode não possuir tarefas e ser designado à um veículo $w$, indicando que este não está em uso e portanto $|N_{w}|=0$.

\subsection{Hipothetical Case}\label{hipcase}

Um caso hipotético de rede de transporte é descrito abaixo, no qual a origem e seis clientes ($C_1$ à $C_6$) são dispostos cartesianamente, sendo a distância entre eles representada pelas distâncias euclidianas dos pontos (Tabela \ref{table:ed}). 

\begin{table}
\centering
\caption{Euclidian distance (ED) between two points in the network.}
\begin{tabular}{l|lllllll} 
\hline\noalign{\smallskip}
\textbf{ED(x,y)} & Origin & $C_{1}$  & $C_{2}$  & $C_{3}$  & $C_{4}$  & $C_{5}$  & $C_{6}$   \\ 
\hline
Origin                  & 0      & 27 & 260 & 253 & 254 & 112 & 90   \\
$C_{1}$                      & 27    & 0   & 265 & 270 & 237 & 114  & 105  \\
$C_{2}$                      & 260   & 265 & 0   & 474 & 212 & 371 & 175  \\
$C_{3}$                     & 253    & 270 & 474 & 0   & 507 & 178 & 307  \\
$C_{4}$                      & 254    & 237 & 212 & 507 & 0   & 346 & 231  \\
$C_{5}$                      & 112    & 114  & 371 & 178 & 346 & 0   & 198  \\
$C_{6}$                      & 90    & 105 & 175 & 307 & 231 & 198 & 0    \\
\hline\noalign{\smallskip}
\end{tabular}
\label{table:ed}
\end{table}

As tarefas e a frota de veículos são detalhadamente descritos na Tabela \ref{table:jobvehicleinfo}. As informações sobre as tarefas definem a prioridade e urgência de suas entregas. Três veículos heterogêneos($V_1$, $V_2$ e $V_3$) são disponibilizados para transportá-las. Os preços $F$ dos veículos são diretamente proporcionais às suas capacidades de transporte.



\begin{table}
\centering
\caption{Jobs and vehicles detailed informations.}
\begin{tabular}{lllll|lll} 
\hline\noalign{\smallskip}
\multicolumn{1}{l}{Job} & $P_i$ & $d_i$  & $w_i$  & $s_i$ & \multicolumn{1}{l}{Vehicle} & $Q_k$  & $F_k$    \\ 
\hline
$J_1$                        & 25 & 266 & 1.8 & 20 & $V_1$                           & 204 & 1224  \\
$J_2$                        & 49 & 347 & 2.3 & 31 & $V_2$                           & 186 & 1116  \\
$J_3$                        & 36 & 303 & 4.3 & 25 & $V_3$                           & 160 & 960   \\
$J_4$                        & 96 & 431 & 4   & 86 &                              &     &       \\
$J_5$                        & 52 & 177 & 2   & 33 &                              &     &       \\
$J_6$                        & 43 & 315 & 4.6 & 42 &                              &     &       \\
\hline\noalign{\smallskip}
\label{table:jobvehicleinfo}
\end{tabular}
\end{table}

A Figura \ref{fig:ganttchart1} descreve visualmente a solução ótima para a instância. Neste caso hipotético, todos os três veículos foram utilizados durante a entrega, possuindo tempos
de início $S_1$,$S_2$ e $S_3$ iguais a 180, 301 e 88, respectivamente. A porcentagem no final de um trajeto representa o espaço ocupado pelas tarefas carregadas no veículo. Dentre as seis tarefas, apenas $J_6$ foi entregue sem atrasos.

\begin{figure}[ht]
	\centering
    \includegraphics[width=1\textwidth]{Images/VISUAL_REP2} 
    \caption[]{Gráfico de Gantt com a descrição visual da solução.}
  	\label{fig:ganttchart1}
\end{figure}


Na solução ótima da instância, os tempos de completude $C$ das tarefas são, respectivamente: 276, 180, 88, 301, 52 e 137. 

Os tempos de destino $D$, que indicam o momento em que o pedido chega àos clientes são: 328, 445, 378, 565, 200 e 270. 

No cálculo da diferença entre o tempo de destino e a o prazo de entrega, obtêm-se os seguintes valores de atraso $T$:  62, 98, 75, 134, 23 e 0.

O resultado ótimo da função objetivo possui valor absoluto $6127.5$,sendo composto por três partes integrantes do problema. A primeira, é dada pelos custos de trajeto dos três veículos, que são calculados em $DC = (112+178+253) + (90+175+260) + (27+237+254) = 1586$. 

A segunda parte é definida pelos custos de utilização de veículo, que neste contexto será total, uma vez que todos veículos foram utilizados. Desta forma, $VC =  1224+1116+960 = 3300$.

Os atrasos $T$ serão multiplicados por suas respectivas penalidades $w$.
Isto posto, o custo total de atrasos ponderados é $TC = (62*1.8) + (98*2.3) + (75*4.3) + (134*4) + (23*2) + (0*4.6) = 1241.5$.

Portanto, ao combinar as três parcelas da função objetivo, é obtido o valor final $DC + VC + TC = 6127.5$ na solução ótima da instância. 


\section{Abordagem de Solução}\label{solutionapproach}

São tratadas no artigo três abordagens para solucionar o Problema de Sequenciamento de Produção e Entrega, sendo duas versões da metaheurística Iterated Local Search (ILS) e um Algoritmo Genético (G.A.). Ullrich (2013)\cite{ullrich2013} atingiu bons resultados com a aplicação de um Algoritmo Genético para o ambiente de máquinas paralelas do problema.

O método de busca local aplicado junto aos algoritmos é o procedimento VND (Mladenovic and Hansen 1997)\cite{mladenovic1997variable}, com ordenação aleatória de vizinhanças (RVND). São descritas duas versões de RVND neste trabalho. Em uma das versões, uma técnica de aprimoramento interno de rotas é aplicada. 

A estrutura de ambas Iterated Local Search são similares, diferenciando-se na chamada dos métodos de busca local RVND. O Algoritmo Genético (G.A.) desenvolvido utiliza técnicas de Torneio Binário e 2-point Crossover. 

\subsection{Soluções Iniciais}\label{initialsolutions}

A qualidade de um ótimo local obtido por método de busca local depende da solução inicial trabalhada (El-Ghazali Talbi, 2009)\cite{talbi2009metaheuristics}. As regras para a criação de soluções iniciais utilizadas aqui originam-se do problema de Permutation Flow Shop, sendo estas Apparent Tardiness Cost (ATC), Weighted Modified Due Date (WMDD) e Weighted Earliest Due Date (EDD) (Molina-Sánchez and González-Neira, 2015)\cite{molina2016grasp}.

O conjunto de regras têm por objetivo designar uma ordem favorável para o sequenciamento de tarefas. Por se tratar de uma Frota Heterogênea de Veículos, a ordem gerada pelas regras pode ou não ser atendida devido às restrições de capacidade dos veículos. Caso nenhuma das três regras gere sequência viável, uma solução inicial aleatória é utilizada.

\subsection{Operadores de Vizinhança}\label{nboperators}

O processo de busca local visa aprimorar uma solução atual ao considerar soluções similares pelas operações de vizinhança definidas. Neste trabalho, são consideradas apenas soluções viáveis no processo. Portanto, todas as soluções em que a soma dos tamanhos das tarefas exceda a capacidade de transporte de um veículo serão desconsideradas. Matematicamente, uma solução $S$ é descartada se:
\begin{equation}\\
 \label{eq:invalidsol}
Q_{k} < \sum\limits_{i=1}^{|N_k|} s_{i};  \forall k \in K;
\end{equation} 

Para constituir o conjunto de vizinhanças de uma solução, estas foram subdivididas em dois subconjuntos: vizinhanças Intra-Rota e Inter-Rota. 


\subsection{Vizinhanças Intra-Rota}\label{intraroutenb}
Neste subconjunto, as operações aplicadas para diversificação da solução são restritas a alterações internas de um veículo, influenciando somente na ordem de entrega das tarefas carregadas por este. Seja $R$ uma solução viável para o problema e $R_{i}$ a rota completa de um veículo $i$. São definidas as operações:

\begin{itemize}
  \item \textbf{Swap-Adj-Job}($R_{i}$) — Troca de posição duas tarefas adjacentes na rota $R_{i}$. \\
  
  \item \textbf{Insert-Job}($R_{i}$) — Insere uma tarefa nas demais posições da rota $R_{i}$.\\
  
  \item \textbf{2-opt}($R_{i}$) — Realiza a operação de 2-opt em todas combinações de arcos distintos da rota $R_{i}$, i.e., seleciona dois arcos distintos, os remove e reconecta os clientes de forma que a rota seja modificada e permaneça interligada.
\end{itemize}

\subsection{Vizinhanças Inter-Rota}\label{interroutenb}

As operações de vizinhança do tipo Inter-Rota consideram duas ou mais rotas durante sua aplicação, realizando alterações em mais de uma rota ao mesmo tempo. Durante o processo, as operações aplicadas podem gerar soluções inviáveis, porém estas não serão consideradas neste trabalho.

Seja $R$ uma solução viável para o problema e $R_{i}$ e $R_{w}$ as rotas completas realizadas pelos veículos $i$,$w$ $\in$ $K$. Ademais, o conjunto de tarefas carregadas por um veículo $i$ é representado por $N_i$. São definidas as operações:
\begin{itemize}
\item \textbf{Swap-Job}($R_{i}$, $R_{w}$) — Trocam de posição duas tarefas $a$ $\in$ $N_{i}$ e $b$ $\in$ $N_{w}$ entre as duas rotas, de forma que $a$ receberá a posição antiga de $b$ na nova rota e vice-versa.\\ 

\item \textbf{Insert-Job}($R_{i}$, $R_{w}$) — Insere uma tarefa $a$ $\in$ $N_{i}$ nas demais posições da rota $R_{w}$.\\

\item \textbf{Swap-Adj-Vehicles}($R_{i}$, $R_{w}$) — Trocam de posição dois veículos adjacentes $i$ e $w$ carregando consigo seus lotes de tarefas, i.e., caso o veículo $i$ agora parta após o veículo $w$, o primeiro ($i$) deverá esperar todas as tarefas do segundo ($w$) sejam processadas para que as suas se iniciem na máquina.\\

\item \textbf{Insert-Vehicle}($R_{i}$) — Insere um veículo $i$ juntamente com suas tarefas atreladas ($N_i$) nas demais posições da solução, i.e., insere seu lote de tarefas antes, entre ou após outros veículos.\\
\end{itemize}

\subsection{Abordagens de RVND}\label{rvndapproaches}

O processo de busca local é realizado por VND (Mladenovic and Hansen 1997)\cite{mladenovic1997variable}, utilizando sete operadores de vizinhança e ordenação aleatória de vizinhanças (RVND). São empregadas duas versões de RVND, com técnicas diferentes de organização dos operadores.

A primeira versão, descrita em Algorithm \ref{algo:rvnd}, consiste de percorrer aleatoriamente pelo conjunto de vizinhanças à procura de melhorias na solução atual, e em seguida reiniciar este procedimento quando alguma melhora é alcançada. Do contrário, caso nenhuma melhoria seja obtida na execução, a busca local é encerrada.
O algoritmo possui um único parâmetro: uma solução $S$, e se inicia atribuindo $S$ à melhor solução encontrada $S*$ (Passo 1).

\begin{algorithm}
\label{algo:rvnd}
\AlFnt \small
\LinesNumbered
\Input{Solution $S$}
\Output{Better or equal $S*$ solution}
  \caption{RVND($S$)}
  
  $S* \gets S;$\\
  $NeighborhoodSet \gets$\textup{Random Order($Neighborhoods$);}\\
  \For{$i \gets$ \textup{1 in} $NeighborhoodSet$}{
        $currNeighborhood \gets NeighborhoodSet[i];$ \tcp{Select Neighborhood}
        $S \gets$ \textup{currNeighborhood(S)}; \tcp{Apply Local Search}
        \If{\textup{f($S$) $\leq$ f($S*$)}}{
            {$S* \gets S;$\\
            $NeighborhoodSet \gets$\textup{Random Order($Neighborhoods$);}\\
            $j \gets 1;$ \tcp{Restart Local Search}
            }
        }
         
    }
  \Output{$S*$}
\end{algorithm}

 Em seguida, todo o conjunto de vizinhanças é distribuido em ordem aleatória em $NeighborhoodSet$ (Passo 2). Todas as vizinhanças em $NeighborhoodSet$ são visitadas na ordem sorteada (Passos 3-10) e seus vizinhos $S$ são comparados à melhor solução $S*$ (Passos 5-6). Caso algum vizinho seja satisfatório, ele é então salvo em $S*$ (Passo 7) e o processo de busca é reiniciado com nova ordem aleatória (Passos 8-9), caso contrário o algoritmo termina. A melhor solução $S*$ encontrada na busca local é retornada.



A segunda versão, RVND-Custom,  é baseada na técnica de aprimoramento interno (Penna and Ochi, 2013)\cite{penna2013iterated}, onde as vizinhanças externas à uma rota Inter-Route Neighborhoods são analisadas, e caso seja obtida melhora na solução, as vizinhanças internas Intra-Route Neighborhoods são acionadas para a aprimorar ainda mais. A aplicação é descrita em Algorithm \ref{algo:rvnd2}. 

O algoritmo possui um parâmetro: uma solução $S$, e é iniciado ao atribuir $S$ à melhor solução encontrada $S*$ (Passo 1). Em seguida, o conjunto de vizinhanças Inter-Rota é randomicamente distribuido e armazendo em $InterRoute$ (Passo 2). Todos as vizinhanças são visitadas na ordem sorteada (Passos 3-22), sendo seus vizinhos $S'$ analisados (Passos 4-5) e caso sejam melhores do que $S$, o aprimoramento interno de rota se inicia (Passos 6-18). 

\begin{algorithm}
\label{algo:rvnd2}
\AlFnt \small
\LinesNumbered
\Input{Solution $S$}
\Output{Better or equal $S*$ solution}
  \caption{RVND-Custom($S$)}
  
  $S* \gets S;$\\
  $InterRoute \gets$\textup{Random Order($Inter$-$Route$ $Neighborhoods$);}\\
  \For{$i \gets$ \textup{1 in} $InterRoute$}{
         $currInter \gets InterRoute[i];$ \tcp{Get Inter-Route Neighborhood}
         $S' \gets$ \textup{currInter(S)}; \tcp{Apply Inter Local Search}
         \If{\textup{f($S'$) $\leq$ f($S$)}}{
               {$IntraRoute \gets$\textup{$Intra$-$Route$ $Neighborhoods$;}\\
                 \For{$j \gets$ \textup{1 in} $IntraRoute$}{
                    $currIntra \gets IntraRoute[j];$\tcp{Apply Intra Local Search}
                    $S'' \gets currIntra(S');$\\ 
                     \If{\textup{f($S''$) $\leq$ f($S'$)}}{
                        $S' \gets S'';$\\
                        $j \gets 1;$ \tcp{Restart Intra-Route Socal Search}
                     }
                 }
                }
                $i \gets 1;$\\
                $InterRoute \gets$\textup{Random Order($Inter$-$Route$ $Neighborhoods$);}\\
            }
         \If{\textup{f($S'$) $\leq$ f($S*$)}}{
                {$S* \gets S'$;\\}
            }
    }
  \Output{$S*$}
\end{algorithm}

Em seguida, o conjunto de vizinhanças Intra-Rota é visitado sequencialmente (Passos 8-15) e na hipótese de melhorar novamente (Passos 11-14), a busca interna se reinicia (Passo 13). Do contrário, esta termina e a busca externa é reiniciada com nova ordem aleatória (Passos 16-17). 
A melhor solução encontrada é atualizada a cada iteração da busca externa (Passos 19-21). Ao final do algoritmo, a melhor solução $S*$ é retornada.

\section{Iterated Local Search}

Ao gerar variados ótimos locais, utilizar a Iterated Local Search torna possível obter aprimoramento da qualidade da solução (Talbi, 2009)\cite{talbi2009metaheuristics}. Neste artigo em específico, as aplicações de Iterated Local Search utilizam duas versões de busca local RVND.

Os métodos de perturbação do algoritmos descritos em seguida utilizam os operadores de vizinhança Inter-Rota: \textbf{Swap-Job}($R_{i}$, $R_{w}$) e \textbf{Insert-Job}($R_{i}$). É realizada uma quantidade $\alpha$ de perturbações, sendo $\alpha$ estatisticamente definido na Seção ‘Calibração de Parâmetros’. %Completar com a seção%

\subsection{ILS RVND}
O esquema geral da metaheurística ILS proposta é apresentado em Algoritmo \ref{algo:ilsrvnd}. Existem três parâmetros: $\alpha$ (número de perturbações), $MaxIter$ (quantidade de reinícios de solução) e $MaxIterILS$ (máximo de iterações consecutivas para o algoritmo). Inicialmente, a variável de melhor solução global é inicializada (Passo 1). 

A cada iteração externa, uma nova solução inicial $S$ é gerada (Passo 3) utilizando as regras descritas na Seção \ref{initialsolutions}, e em seguida é feito busca local em $S$ (Passo 4). Após sua possível melhora, o processo de Perturbação é inicializado (Passos 5-12), a solução atual $S’$ é perturbada com intensidade $\alpha$ (Passo 10), é feito busca local RVND (Passo 11) e a melhor solução encontrada é atualizada (Passos 6-9).

\begin{algorithm}
\label{algo:ilsrvnd}
\AlFnt \small
\LinesNumbered
\Input{Parameters of max. iterations numbers}
\Output{Best solution $S*$}
  \caption{ILS-RVND ($ \alpha, MaxIter,MaxIterILS$)}
  
  $S* \gets$ Initialize($S*$);\\
  
  \For{$i \gets$ \textup{1 to} $MaxIter$}{
  
         $S \gets $ \textup {GenerateInitialSolution();}\\
         $S' \gets$ \textup{RVND($s$)};\\
         
        \For{$j \gets$ \textup{1 to} $MaxIterILS$}{
         
            
            \If{\textup{f($S$) $\leq$ f($S'$)}}{
                {$S'\gets S$;\\
                $j \gets 1;$ \tcp{Restart Perturbing Process}}
            }
            
            $S' \gets $\textup{Perturb($S'$, $\alpha$)};\\
            $S' \gets $\textup{RVND($S'$)}; \tcp{Local Search on Perturbed S'}
         }
         
         \If{\textup{f($S'$) $\leq$ f($S*$)}}{
                {$S* \gets S'$;\\}
            }
    }
  \Output{$S*$}
\end{algorithm}

Caso alguma melhora em $S’$ em  relação à solução inicial $S$ seja obtida, o processo de Perturbação é reinicializado (Passo 8). Nos Passos 13-15, $S’$ é comparada a melhor solução $S*$ e finaliza uma iteração do algoritmo. Ao final é retornada a melhor solução encontrada $S*$.

\subsection{ILS-RVND com Aprimoramento de Rota Interna}\label{ilsrvnd2}

Penna and Ochi, 2013 \cite{penna2013iterated} desenvolveram o primeiro modelo de Iterated Local Search com RVND para o Problema de Roteamento de Frota Heterogênea de Veículos (HFVRP) em um ambiente com até cem clientes, e produziram resultados competitivos com aos da literatura. Sua abordagem em lidar com a entrega de mercadorias em específico serviu de inspiração para esta combinação ILS-RVND.

A diferença desta versão de Iterated Local Search para a anterior está na busca local RVND-Custom, que utiliza a técnica de aprimoramento interno de rotas. O pseudocódigo desta aplicação é derivado do Algoritmo \ref{algo:ilsrvnd} ao realizar a substituição referida em Figura \ref{fig:ilsdif}.

\begin{figure}[ht]
	\centering
    \includegraphics[scale=0.072]{Images/ILS_DIF} 
    \caption[]{Mudança entre acionamentos de RVND.}
  	\label{fig:ilsdif}
\end{figure}

Nesta técnica, assim que uma solução atual é aperfeiçoada utilizando operadores externos às rotas, como realizar intercâmbio de tarefas entre veículos, os operadores internos às rotas são acionados.

\section{Genetic Algorithm}\label{genalgo}

Algoritmos Genéticos foram desenvolvidos por J. Holland em meados dos anos 70 (University of Michigan, USA)  para entender o processo adaptativo de sistemas naturais (Talbi, 2009)\cite{talbi2009metaheuristics}. Nesta abordagem, são utilizadas técnicas de Torneio Binário para seleção de soluções e 2-point Crossovers para diversificação da prole. O esquema geral do algoritmo é descrito em Algorithm \ref{algo:genalgo}.

Existem dois parâmetros: $PopSize$ (quantidade de indivíduos na população) e $MaxIter$ (número de iterações em que serão geradas novas populações. O algoritmo é iniciado no Passo 1 ao gerar uma população aleatória $P$, seguido de uma busca local RVND em $P$ (Passo 2). A melhor solução da população é armazenada em $P*$ (Passo 3). 

A cada iteração uma nova solução é inserida em $P'$ até o limite de $PopSize-1$ indivíduos (Passos 6-22). Para gerar uma prole, são escolhidas duas soluções ‘pai’ por Torneios Binários (Passos 7-8), e em seguida são geradas duas mutações destas soluções (Passos 9-10). 


\begin{algorithm}
\label{algo:genalgo}
\AlFnt \small
\LinesNumbered
\Input{Population size and max. iteration number}
\Output{Best solution $P*$ in $MaxIter$ populations}
  \caption{Genetic Algorithm ($PopSize,MaxIter$)}
  
  $P \gets$ \textup{Generate random population($PopSize$);}\\
  $P \gets$ \textup{ RVND($P$);} \tcp{Apply local search to new population P}
  $P* \gets$ \textup{Best($P$);} \tcp{Save best solution of P}
  
  \For{$i \gets$ \textup{1 to} $MaxIter$}{
        $P'  \gets$ \text {\O;}\\
          
        \For{$j \gets$ \textup{1 to} $(PopSize-1)$}{
          
            $Parent1 \gets$ \textup{Binary Tournament(random($P$), random($P$));}\\
            $Parent2 \gets$ \textup{Binary Tournament(random($P$), random($P$));}\\
         
            $Offspring1  \gets$ \textup {Crossover($first, second$); }\\
            $Offspring2 \gets$ \textup {Crossover($first, second$); }\\
         
            \eIf{ \textup{Feasible($Offspring1$) and Feasible($Offspring2$) } }{
          
                \textup{$P' \gets P'$ + BinaryTournament($Offspring1,Offspring2$);}
                
            }{\eIf{ \textup{Feasible($Offspring1$) or  Feasible($Offspring2$)} }{
          
                \textup{$ P' \gets P'$ + Feasible from($Offspring1,Offspring2$);}
                
            }{ 
                \If{\textup{!Feasible($Offspring1$) and !Feasible($Offspring2$) } }{
              
                    \textup{ $P' \gets P'$ + Mutation(random($Parent1,Parent2$));\\}
                    
                }
            }
            }
        }
        $ P' \gets$ P' + P*; \tcp{Include best solution to P'}
        $ P' \gets$ \textup{ Fast Local Search($P'$);}\\
        \If{  \textup{f($P'$) $\leq$ f(Best($P'$))} }{
            \textup{$P' \gets P*$;\\}
        }
        
        $ P \gets$ \text { $P';$} \\
  }
  \Output{$P*$}
\end{algorithm}

O processo de mutação Crossover pode produzir soluções inviáveis, dessa forma a escolha de uma nova solução para a população $P’$ necessita de análise:

\begin{itemize}
  \item No primeiro caso, em que as duas novas mutações são viáveis, estas participam de um Torneio Binário (Passo 12) e a escolhida será adicionada à população.
  \item No segundo caso, onde apenas uma das soluções é viável, a única prole viável será inserida na população $P’$ (Passo 15).
  \item No último caso, se as duas mutações geradas são inviáveis (Passo 17), uma escolha aleatória entre as soluções ‘pai’ é feita e sofrerá uma nova mutação Crossover (Passo 18), sendo adicionada em seguida.
\end{itemize}  
	Após a obtenção de $PopSize-1$ indivíduos em $P’$, é inserida a melhor solução $P*$ encontrada até o momento (Passo 23). Com a população completa, é realizada uma busca local rápida (Passo 24) em todos os indivíduos. Este método é descrito na Seção \ref{algo:fastlocalsearch}.
Por fim, a melhor solução $S*$ é atualizada (Passos 25-26) e a população $P’$ torna-se a população atual $P$, para nas próximas iterações gerar novos indivíduos (Passo 25).

\subsection{Fast Local Search}\label{fastlocalsearch}

Nesta seção é descrito um procedimento de busca local chamado Fast Local Search. Métodos de busca local convencionais como VND e RVND podem ser computacionalmente custosos acionados consecutivas vezes, apesar de possibilitarem melhoras significativas na qualidade da solução. Dessa forma, foi implementado um método de busca local simples para lidar com as soluções do algoritmo populacional. O procedimento é descrito em  Algoritmo \ref{algo:fastlocalsearch}.

\begin{algorithm}
\label{algo:fastlocalsearch}
\AlFnt \small
\LinesNumbered
\Input{Solution $S$}
\Output{Better or equal $S*$ solution}
  \caption{Fast Local Search($S$)}
  
  $S* \gets S;$\\
  $NeighborhoodSet \gets$\textup{$Inter$-$Route$ and $Intra$-$Route$ $Neighborhoods$;}\\
  \For{$i \gets$ \textup{1 to} $NeighborhoodSet$}{
  
         $currNeighborhood \gets NeighborhoodSet[i]$;\\
         $S' \gets$ \textup{currNeighborhood(S)};\\
       
         \If{\textup{f($S'$) $\leq$ f($S*$)}}{
                {$S* \gets S'$;\\}
            }
    }
  \Output{$S*$}
\end{algorithm}

O algoritmo possui um parâmetro: uma solução $S$ e se inicia ao atribuir $S$ à melhor solução global $S*$ (Passo 1). Todo o conjunto de vizinhanças (Inter-Rota e Intra-Rota) é atribuido à $NeighborhoodSet$ (Passo 2). Em seguida, o método percorre sequencialmente as vizinhanças em $NeighborhoodSet$ (Passos 3-8) e analisa seus vizinhos (Passos 4-5). Em cada vizinhança, a melhor solução $S'$ da vizinhança é comparada com a melhor solução global e $S*$ é atualizada (Passos 6-8).
Por fim, o método de busca local retorna a melhor solução encontrada.



\section{Experimentos Computacionais}\label{experiments}


%All the heuristic algorithms were coded in C++ and executed on a PC machine IntelR Core TM i7-4790K CPU @ 4.00GHz x 8 with 32GB RAM, running Ubuntu 14.04 LTS 64 bits. The quality of the solutions were measured by the relative percentage deviation (RPD) from the best known solution (reference solution). The RPD measure represents the percentage of how much experimental results differs from a reference value, and is calculated following the equation: 
%\begin{equation}\label{eq:rpd}
%RPD(\%)= 100 \times \frac{TT_{\mbox{experimental}} - TT_{\mbox{reference}}}{TT_{\mbox{reference}}}
%\end{equation}
%where $TT_{\mbox{reference}}$ is the value of the reference solution, and %$TT_{\mbox{experimental}}$ is the obtained solution by  a given heuristic. 

Nesta Seção são apresentados os experimentos realizados em cima dos três algoritmos e o software CPLEX.
Todos os algoritmos foram codificados em C++ e executados em uma máquina Intel(R) Core TM i7-4790K CPU @ 4.00GHz x 8 with 32GB RAM, rodando Ubuntu ??.?? 64 bits. 

A métrica de comparação utilizada é o desvio relativo percentual (RPD), sendo utilizada a melhor média entre os algoritmos ($f_{best}$) para a comparação entre elas. O RPD mede percentualmente o quanto os resultados experimentais ($f_{method}$) diferem do valor de referência:

\begin{equation}
\label{rpd}
	RPD = \frac{f_{method} - f_{best} }{ f_{best}} * 100\%
\end{equation}

A performance das heurísticas aplicadas foram testadas em todas 1740 instâncias, sendo cada heurística executada cinco vezes em cada instância. A média entre das execuções é considerada para as comparações. O software CPLEX foi executado uma vez para cada instância pequena, onde $N \in \{8,10,15,20\}$ e $V \in \{3,4,5,6\}.$

\subsection{Efetividade em Instâncias Pequenas}\label{small-instances-effectiveness}

\begin{figure}
\centering     %%% not \center
\subfigure[Average RPD with $N = 10$]{\label{fig:a}\includegraphics[width=60mm]{Images/Small Instances/Avg RPD 10 Jobs (Int)}}
\subfigure[Average RPD with $N = 15$]{\label{fig:b}\includegraphics[width=60mm]{Images/Small Instances/Avg RPD 15 Jobs (Int)}} 
\subfigure[Average RPD with $N = 20$]{\label{fig:c}\includegraphics[width=60mm]{Images/Small Instances/Avg RPD 20 Jobs (Int)}} 
\subfigure[General Average RPD]{\label{fig:d}\includegraphics[width=60mm]{Images/Small Instances/Task 4 Average RPD Small (Int)}} 
\caption{Gráfico médio e intervalos de confiança com nível de confiança de 95\% para instâncias pequenas.}
\end{figure}



\section{Conclusions}\label{conclusions}

\subsubsection*{Acknowledgments.}
The authors thanks the financial support of FAPEMIG, CAPES and CNPq, Brazilian research agencies.

\bibliographystyle{ieeetr}
\bibliography{Bibliography/papers.bib}


\end{document}