\documentclass[citeauthoryear]{llncs}
\newcommand{\keywords}[1]{\textbf{Keywords:}\quad #1}
\usepackage{cite}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{subfigure}

%Packages and settings to run the algorithms properly 
\usepackage[ruled]{algorithm2e}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

%Adds the possibility to Create Sub-Sub-Sections
\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}


%\graphicspath{ {images/} }
\renewcommand{\tabcolsep}{3mm}

\title{Heurísticas para um Problema Integrado de Sequenciamento da Produção e Roteamento de Veículos de Frota Heterogênea
}
\author{Gabriel de P. Felix  \and José E. C. Arroyo \ }
\institute{Department of Computer Science, Universidade Federal de Viçosa,\\ Vi\c{c}osa - MG, 36570-900, Brazil\\
gabriel.felix@ufv.br,  jarroyo@dpi.ufv.br}


\begin{document}

\maketitle
\begin{abstract}
%Este artigo aborda o problema de programação integrado de sequenciamento da produção de uma máquina linear e roteamento de veículos para entrega. Nesta versão, tarefas possuem penalidades, datas de vencimento e diferentes tamanhos, com veículos dispostos em uma frota heterogênea e limitada de veículos (HFVRP). Os critérios a serem minimizados são: o atraso total ponderado, custos de transporte e distância total percorrida.
%O problema é classificado como NP-Difícil no senso comum, exigindo a aplicação de heurísticas para solucioná-lo.
%São propostas duas heurísticas Iterated Local Search, Algoritmo Genético (AG) e um modelo misto de programação linear inteira (MILP). Foram geradas instâncias de pequeno e grande porte (até cem clientes), sendo os resultados comparados com o Solver CPLEX. Análises estatísticas mostram que as heurísticas aplicadas possuem performance em tempo e qualidade superior às soluções do software a medida em que o número de clientes aumenta.

This paper address an integrated job schedulling and vehicle routing problem, where jobs contains different sizes, penalties and due dates. To deliver them, there are vehicles from a limited heteregenous fleet (HFVRP). The minimization criteria are: total weighted penalty, transport costs and total distance traveled. 
The given problem is classified as NP-Hard, demanding heuristics approaches to obtain near-optimal solutions in reasonable computational time. There are proposed two versions of Iterated Local Search (ILS), one Genetic Algorithmn (GA) and a Mixed-Integer Linear Programming (MILP) model to solve it. In addition, were also generated small and big instances (with at most one hundred customers) and the results compared to CPLEX Solver. 
Estathistical Analysis shows that heuristics approaches obtained better quality solutions in much less time than the solver.

\keywords{Single machine scheduling, vehicle routing, heterogeneous fleet, time windows, linear programming, meta-heuristics.}
\end{abstract}

\section{Introdução}\label{introduction}

Para aumentar a competitividade no mercado global, as indústrias tem-se concentrado na otimização da cadeia de suprimentos.
A cadeia de suprimentos é o conjunto de atividades/processos que envolvem a produção, armazenamento e transporte de produtos ou serviços. Estas atividades  incluem  a compra de matérias-primas, controle de estoque,  produção dos produtos, e entrega dos produtos aos clientes finais dentro dos prazos estabelecidos. 

Todas essas atividades devem ser muito bem planejadas e otimizadas para que possam entregar produtos de qualidade e gerar resultados positivos. Os objetivos primordiais  que são buscados pela cadeia de suprimentos são: redução de custos, cumprimento de prazos e satisfação dos clientes.


Este trabalho tem como objetivo propor uma abordagem de tomada de decisão para um problema integrado de programação da produção e transporte (roteamento de veículos). 
 Neste problema integrado, um determinado conjunto de tarefas de tamanhos diferentes deve ser processado em uma máquina (disponível numa fábrica) e entregue aos respectivos clientes por uma frota heterogênea de veículos, levando em consideração os prazos de entrega. 

O objetivo é minimizar o atraso total ponderado e os custos de transporte (com relação aos custos variáveis dos veículos e custos/tempos de viagem dos veículos). Isoladamente, o problema de agendamento em uma máquina linear com minimização do atraso total é provado como NP-Difícil (Du and Leung, 1990)\cite{du1990}, consequentemente, esta abordagem também é NP-Difícil.

Problemas de programação de produção e roteamento de veículos são dois problemas de otimização combinatória bem estudados na literatura e geralmente são estudados de forma separada.

Pelo conhecimento dos autores deste artigo, o problema integrado de sequenciamento em uma máquina simples e roteamento com veículos de capacidades e custos variáveis,  tarefas de diferentes tamanhos, e  com o objetivo de minimizar o atraso ponderado total e custos de entrega, ainda não foi abordado na literatura. São componentes deste trabalho:

\begin{itemize}
  \item Duas abordagens heurísticas de Iterated Local Search (ILS) e um Algoritmo Genético (G.A.).
  \item Um modelo de programação linear para solução dos problemas integrados.
\end{itemize}

Na Seção \ref{lit-review} são apresentados estudos prévios na literatura. Em seguida, nas Seções \ref{problemdescription} e \ref{mathematicalmodel} a descrição do problema e o modelo MILP proposto. A Seção \ref{solutionrepresentation} e Subseção \ref{hipcase} contém a representação de solução escolhida e um caso hipotético do problema, respectivamente. 

Na Seção \ref{instancesgen} é detalhamente explicitada a geração de instâncias. Os operadores de vizinhança e métodos de busca local RVND são apresentados na Seção \ref{nboperators}. A solução inicial utilizada nos algoritmos é citada na Seção \ref{solutionapproach}.

As duas versões de Iterated Local Search são descritas na Seção \ref{ils}, e o Algoritmo Genético na Seção \ref{genalgo}. Em seguida, experimentos computacionais são mostrados na Seção \ref{experiments}, sendo a calibração de parâmetros descrita na Subseção \ref{parameters-calibration} e os resultados dos algoritmos nas Subseções \ref{small-instances-results} e \ref{large-instances-results}. Por fim, o trabalho é concluido na Seção \ref{conclusions}.


\section{Revisão Literária}\label{lit-review}

Na literatura existem alguns trabalhos sobre o problema integrado de agendamento de produção e entrega.

%inserir aqui os problemas de agendamento
Hall and Potts (2003) \cite{hall2003supply} abordaram o problema integrado de agendamento de produção e entre de lotes, com vários clientes e manufaturas, e definiram assim a área de Supply Chain Scheduling. Em seu trabalho, o objetivo principal era minimizar os custos de agendamento e entrega, utilizando diversos objetivos clássicos de agendamento. A cooperação entre a manufatura e o fornecedor foi apresentada como fator importante de diminuição de custos no agendamento.

Ullrich  (2013) \cite{ullrich2013} aborda um problema integrado que consiste  na programação de um conjunto de tarefas em máquinas paralelas com tempos de espera dependentes da máquina. As tarefas processadas são distribuídas utilizando uma frota heterogênea de veículos.  Este autor considera tempos de processamento, janelas de tempo de entrega e tempos de serviço. Para minimizar o atraso total das tarefas, o autor apresenta um modelo de PLIM, duas abordagens clássicas de decomposição e um Algoritmo Genético.

Condotta, Knust, Meier, and Shakhlevich (2013)\cite{condotta2013tabu} estudaram o problema de minimizar o atraso máximo de uma máquina linear juntamente com o transporte de tarefas, considerando datas de entrega para os trabalhos e veículos limitados de mesma capacidade. Neste trabalho foi formulado um modelo MILP do problema, desenvolvido um algoritmo de Busca Tabu para soluções parciais e então calculada a entrega em tempo polinomial para as soluções parciais.

Xiao, Konak (2015) \cite{xiao2015simulating} apresentaram o problema de Green Vehicle Routing and Schedulling (GVRSP) considerando condições depentendes do tempo de tráfego com múltiplas funções objetivo, como reduzir emissão total de CO$_{2}$, distância total percorrida e tempo total de trajeto. Uma nova formulação matématica é proposta, e também um algoritmo de Simulated Annealing (SA) para resolver instâncias de grande porte. Resultados mostram que até 50\% da emissão de CO$_{2}$ pode ser atingida, com reduções médias de 12\% e 28\% comparado à métodos tradicionais de roteamento.

Cheng, Leung and Li (2015) \cite{cheng2015integrated} estudaram o problema integrado de produção e entrega considerando o processamento em lotes em uma máquina, desde que respeite sua capacidade. Em seu trabalho, os tamanhos de tarefas e tempos de processamento são arbitrários, e veículos contam com capacidades idênticas. Foi gerado um limite inferior (lower bound) para o custo total ideal, e implementado um algoritmo de Colônia de Formigas, obtendo bons resultados e executando em tempo curto para instâncias de grande porte.

Billaut, Croce and Ta (2017) \cite{billaut2017tabu} abordaram o problema integrado de agendamento de produção em entrega em um ambiente de produção Flow Shop com apenas um veículo disponível. Foi minimizado o atraso total das entregas, sendo implementados dois algoritmos de Tabu Search e uma mateurística (matheuristic). Experimentos foram realizados em conjuntos de dados aleatórios.

Wang, Yao, Sheng and Yang (2019) \cite{wang2019minimizing} estudaram o problema integrado de produção e distribuição de tarefas para uma máquina linear e múltiplos veículos. Neste ambiente, é possível trocar uma máquina entre duas produções adjacentes. O objetivo de minimizar a emissão total de carbono foi acrescentado ao de minimizar os custos totais. Foram desenvolvidos um modelo MILP para a solução e em seguida um algoritmo híbrido de Busca Tabu. 

Ghannadpour and Zarrabi (2019) \cite{ghannadpour2019multi} abordaram o problema multi-objetivo de frota heterogênea integrada a produção, com minimização de energia de acordo com novos requisitos sustentáveis. São apresentados dois casos de minimização, onde são tratados o número de veículos alugados e a satisfação dos clientes, acrescentado à minimização de energia(primeiro caso) e minimização de distância percorrida(segundo caso). É apresentada uma nova formulação matemática para o problema de roteamento de veículos com janelas de tempo (VRPTW) e desenvolvida uma nova solução baseada em um algoritmo evolucionário.

Liu, Wenli and Kunpeng Li, and Zou (2020) \cite{liu2020coordinated} estudaram o problema integrado de produção e entrega para uma máquina linear, com objetivo de minimizar a soma dos tempos de entrega. Neste trabalho, os veículos são limitados e possuem mesma capacidade. É proposto um algoritmo de Variable Neighborhood Search (VNS) e complementado com um algoritmo de Busca Tabu para intensificação. Os resultados são comparados com o Solver CPLEX e dois algoritmos de heurísticas da literatura, obtendo-se bons resultados.


Tamannaei and Morteza (2019)\cite{tamannaei2019} abordaram o problema de programação linear para o problema de minimização do atraso ponderado total e custos de entrega. Em seu trabalho, as tarefas possuem pesos iguais e veículos possuem mesmo custo e capacidade. Foram propostos um modelo MILP para o problema, um Algoritmo Genético (GA) e um método exato Branch-and-Bound (B\&B).


\section{Descrição do Problema}\label{problemdescription}

Nesta seção, o problema discutido neste artigo é apresentado juntamente ao seus parâmetros, índices, variáveis de decisão. Em seguida, a função multiobjetivo tratada no problema é descrita em partes.

\begin{tabbing}
\phantom{$D_{n100}\ $}\= \kill
\textbf{Indices:} \\
\\
$i,j$\>  Index of jobs.\\
$k$\>  Index of vehicles.\\
$K$\>  Number of vehicles.\\
$N$\>  Number of jobs.\\
\\
\textbf{Instance Parameters:}\\
\\
$Q_{k}$\>  Capacity of each vehicle $k$.\\
$F_{k}$\>  Cost of each vehicle $k$.\\
$P_{i}$\>  Processing time associated to job $i$.\\
$t_{ij}$\>  Travel time between customer of job $i$ and customer of job $j$.\\
$w_{i}$\> Penalty applied to delivery tardiness of job i.\\
$s_{i}$\>  Size of job $i$.\\
$d_{i}$\>  Due date associated to job $i$.\\
\\
\textbf{Decision Variables:}\\
\\
$C_{i}$\>  Completion time of job $i$\\
$X^{k}_{ij}$\>  Binary decision variable which indicates with value '1' that a vehicle {k}\\\> 
                went from customer of job $i$ to customer of job $j$, and '0' otherwise.\\
$Y_{k}$\>  Binary variable which represents with value '1' if a vehicle $k$ is used,\\\>
            and '0' otherwise.\\
$S_{k}$\>  Time of a vehicle $k$ starts to be used.\\
$A_{ij}$\>  Binary variable which represents if a job $i$ is processed before job $j$,\\
\> value '1' if it's true, and '0' otherwise.\\
$D_{i}$\>  Delivery time of job $i$.\\
$T_{i}$\>  Tardiness of job $i$.\\
\end{tabbing}

Seja uma máquina linear que lidará com $N$ tarefas, isto é, cada tarefa $i$ de tamanho $s_i$ deverá ser processada em sequência a partir do início do processo ($t=0$). Um cliente ordena somente uma tarefa. Caso uma tarefa $i$ seja processada antes de uma tarefa $j$ na máquina, a variável $A_ij$ possuirá valor ‘1’, ou ‘0’ caso contrário.  O tempo de completude de processamento para tarefa $i$ é representado por $C_i$. 
Para a entrega das tarefas, são disponibilizados $K$ veículos, realizando circuitos partindo da origem ‘O’,  sendo a distância entre dois clientes $i$ e $j$ representada por $t_ij$. Na rota percorrida para entrega, caso uma tarefa $i$ seja entregue imediatamente anterior à uma tarefa $j$ e seja entregue por um veículo $k$, esta será representada pela variável $X^{k}_{ij}$ com valor ‘1’, ou ‘0’ caso contrário. A distância de trajeto entre dois clientes $i$ e $j$ é representada por $t_{ij}$. 

Cada veículo $k$ possui capacidade $Q_k$ e custo de utilização $F_k$, além de possuir tempo de ínicio $S_k$. Caso um veículo $k$ seja utilizado, será representado em $Y_k$ com o valor ‘1’, ou ‘0’ caso contrário. 

Cada tarefa $i$  possui tempo de processamento $P_i$ e data de vencimento $d_i$ vinculada, que pode ser penalizada por uma constante $w_i$ multiplicada pelo seu atraso $T_i$. O tempo de chegada no destinatário é representado por $D_i$.
A variável de atraso $T$ é dada por $D_i-d_i$, i.e., a diferença entre o tempo de chegada e a data de vencimento. 

A minimização do trajeto de entrega, custos utilização de veículos e atraso ponderado total é representada pela função objetivo: 

\begin{equation}
    \label{eq:objfull}
    \min \sum_{i,j=0}^N\sum_{k=0}^K X^{k}_{ij}*t_{ij}  
    + \sum_{k=0}^K F_{k}*Y_{k} + \sum_{i=1}^N w_{i}*T_{i}
\end{equation}


%Quando não tratado o Problema de Minimização de Atraso, resta o Problema de Roteamento com Frota Heterogênea de Veículos (HFVRP), uma versão de VRP, que separadamente é strong NP-Hard (Chen,2010)\cite{chen2010integrated}.  Por consequência, o problema descrito é também de complexidade strong NP-Hard.

\section{Modelo Matemático}\label{mathematicalmodel}


Nesta seção, um modelo matemático linear misto é apresentado. Este é modelo é uma versão modificada do proposto por (Tamannaei and Rasti-Barzoki, 2019)\cite{tamannaei2019}, sendo o primeiro desenvolvido na versão do problema em que veículos possuem mesma capacidades ($Q$) e custos ($F$). O modelo é descrito a seguir:

\setcounter{equation}{0}
\begin{equation}
    \label{mm:obj}
    \min \sum_{i,j=0}^N\sum_{k=0}^K X^{k}_{ij}*t_{ij}  
    + \sum_{k=0}^K F_{k}*Y_{k} + \sum_{i=1}^N w_{i}*T_{i}
\end{equation}
st.

    \begin{equation}
        \label{mm:come-out-1-time}
        \sum_{k=0}^K\sum_{j=0,j\neq i}^N X^{k}_{ij} = 1, \quad \forall i = 1 \dots N\\
    \end{equation}
    
    \begin{equation}
        \label{mm:capacity}
        \sum_{i=0}^N \sum_{j=0, j\neq i}^N {s_{i} *X^{k}_{ij} } \leq Q_{k}*Y_{k},  \quad \forall k = 0 \dots K;  
	\end{equation}%
	\begin{equation}
        \label{mm:vehicle-use}
        \sum_{j=0}^N X^{k}_{0j} = Y_{k}, \quad  \forall k = 0 \dots K;\\
    \end{equation}
    	\begin{equation}
        \label{mm:come-in-and-out}
        \sum_{i=0}^N X^{k}_{ih} = \sum_{j=0}^N X^{k}_{hj}; \quad \forall h = 0 \dots N;\\ \forall k = 0 \dots K\\
    \end{equation}
     \begin{equation}
        \label{mm:proc-order-1}
        A_{ij}+A_{ji}=1; \quad  \forall i,j = 0 \dots N; i\neq j;
    \end{equation}
    
    \begin{equation}
        \label{mm:proc-order-2}
        A_{ij}+A_{jr}+A_{ri} \geq 1; \quad \forall i,j,r= 0 \dots N; i\neq j\neq r;\\
    \end{equation}
    
     \begin{equation}
        \label{mm:comp-time}
        C_{j} = \sum_{i=1,i\neq j}^N (P_{i}*A_{ij}) + P_{j};
        \quad \forall j=1 \dots N;    
    \end{equation}
    
    \begin{equation}
        \label{mm:big-m}
        S_{k}\geq C_{j} - M*(1- \sum_{i=1,i\neq j}^N X^{k}_{ij});
        \quad \forall j=1 \dots N; \forall k=0 \dots K;
    \end{equation}
    
    \begin{equation}
        \label{mm:big-m-2}
        D_{j}-S_{k} \geq t_{0j} - M*(1 - X^{k}_{0j}); \quad \forall k=0 \dots K; \forall j=1 \dots N
    \end{equation}
     \begin{equation}
        \label{mm:big-m-3}
        D_{j}-D_{i} \geq t_{ij} - M*(1 -\sum_{i=1}^N X^{k}_{ij}); \quad \forall i,j=1 \dots N;
    \end{equation}
    
     \begin{equation}
        \label{mm:tardiness}
        T_{i} \geq D_{i}-d_{i}; \quad \forall i=1 \dots N;
    \end{equation}
    
    \begin{equation}
        \label{mm:comp-time-origin}
        C_{0}=0;
    \end{equation}
    
    \begin{equation}
        \label{mm:dest-time-origin}
        D_{0}= 0;
    \end{equation}
    
     \begin{equation}
        \label{mm:tardiness-origin}
        T_{0}= 0;
    \end{equation}
    \begin{equation}
        \label{mm:xijk-binary}
        X_{ijk}\in \{0,1\};  \quad \forall i,j=0 \dots N, \forall k=0 \dots K;
    \end{equation}
    \begin{equation}
        \label{mm:aij-binary}
        A_{ij}\in\{0,1\};  \quad \forall i,j=1 \dots N;
    \end{equation}
    \begin{equation}
        \label{mm:yk-binary}
        Y_{k}\in\{0,1\};  \quad \forall k=0 \dots N;
    \end{equation}
    \begin{equation}
        \label{mm:sk-geq-zero}
        S_{k}\geq 0;  \quad  \forall k=0 \dots K;
    \end{equation}
     \begin{equation}
        \label{mm:tardiness-geq-zero}
        T_{i}\geq 0;  \quad  \forall i=1 \dots N;
    \end{equation}
    \begin{equation}
        \label{mm:dest-time-geq-zero}
        D_{i}\geq 0;  \quad \forall i=1 \dots N;
    \end{equation}

The objective function (\ref{mm:obj}) is to minimize the travel distance, total tardiness weight of the jobs and the used vehicles costs. Constraints (\ref{mm:come-out-1-time}) ensure that each job is carried by exactly one vehicle.

Constraints (\ref{mm:capacity}) guarantee that sum of jobs in each vehicle doesn't  overcome it's capacity. Constraints (\ref{mm:vehicle-use}) indicates that if a vehicle is in use, it will leave the origin.

Constraints (\ref{mm:come-in-and-out}) ensure that if a vehicle arrives at a customer, it will also leave  that customer. Constraints (\ref{mm:proc-order-1}) and (\ref{mm:proc-order-2}) are to maintenance the processing order, demanding jobs to be processed in a sequential and possible order.

Constraints (\ref{mm:comp-time}) defines the completion time of a job as the sum of previous jobs' processing times and its own. Constraints (\ref{mm:big-m}) guarantee that if a job $j$ is carried by a vehicle $k$, the vehicle start time will be greather than job $j$'s completion time. 

% Help in Constraints 10 and 1
Constraints (\ref{mm:big-m-2}) indicates that if a job $j$ is carried by a vehicle $k$ is the first of its tour, its destination time $D_j$ is greater or equal than the sum of start vehicle time $S_k$ and distance between origin and this customer  Constraints (\ref{mm:big-m-3}) certify that if a job $j$ delivered by a vehicle $k$ isn't the first of its tour, its delivery time will be greater or equal than the sum of the previous job $i$ delivery time $D_i$ and the start vehicle time $S_k$.

Constraints (\ref{mm:tardiness}) defines the tardiness T of a job as the difference between its destination time (D) and its due date (d).   Constraints (\ref{mm:comp-time-origin}), (\ref{mm:dest-time-origin}) and (\ref{mm:tardiness-origin}) certifies that the origin (customer zero) do not assume any impossible values. 

Constraints (\ref{mm:xijk-binary}), (\ref{mm:aij-binary}) and (\ref{mm:yk-binary}) are to define these variables as binary variables. Constraints (\ref{mm:sk-geq-zero}), (\ref{mm:tardiness-geq-zero}) and (\ref{mm:dest-time-geq-zero}) ensure that these variables won't assume negative values.

\section{Representação de Solução}\label{solutionrepresentation}


A representação de uma solução é disposta linearmente, de modo que tarefas e veículos sigam acompanhados de seus respectivos códigos de identificação. O conjunto de tarefas $N$ do problema será dividido em $K$ subconjuntos, sendo cada subconjunto destinado à um veículo específico. O tempo de ínicio de funcionamento de um veículo $k$, denotado por $S_k$, é dado pela soma dos tempos de processamento $P$ destas tarefas somado ao tempo acumulado das tarefas processadas anteriormente (a partir de $t=0$).
Em cada subconjunto há definição de uma rota, que indica o trajeto percorrido por um veículo. Seja $R$ uma solução viável, $k$ $\in$ $K$ um veículo e $R_k$ sua rota, a representação deste trajeto é dada por:

\begin{equation}
R_{k} = O \rightarrow  J_1\rightarrow  J_2\rightarrow ... \rightarrow  J_{|N_{k}|}\rightarrow  O
\end{equation}

Neste contexto, $Ji$ são as tarefas entregues no trajeto e $\forall i=1, ... |N_k|$ $\in$ $N$  e $|N_k|$ a quantidade de tarefas dispostas neste veículo. Todo veículo parte da origem, e deve retornar para ela, visitando cada cliente somente uma vez. A Figura \ref{fig:solutionrep} representa visualmente uma solução.

\begin{figure}[ht]
	\centering
    \includegraphics[width=1\textwidth]{Images/SOL_REP2} 
    \caption[]{Representação de solução com tarefas organizadas em lotes.}
  	\label{fig:solutionrep}
\end{figure}

Um subconjunto de tarefas pode não possuir tarefas e ser designado à um veículo $w$, indicando que este não está em uso e portanto $|N_{w}|=0$.

\subsection{Exemplo Numérico}\label{hipcase}

Um caso hipotético de rede de transporte é descrito abaixo, no qual a origem e seis clientes ($C_1$ à $C_6$) são dispostos cartesianamente, sendo a distância entre eles representada pelas distâncias euclidianas dos pontos (Tabela \ref{table:ed}). 

\begin{table}
\centering
\caption{Euclidian distance (ED) between two points in the network.}
\begin{tabular}{l|lllllll} 
\hline\noalign{\smallskip}
\textbf{ED(x,y)} & Origin & $C_{1}$  & $C_{2}$  & $C_{3}$  & $C_{4}$  & $C_{5}$  & $C_{6}$   \\ 
\hline
Origin                  & 0      & 27 & 260 & 253 & 254 & 112 & 90   \\
$C_{1}$                      & 27    & 0   & 265 & 270 & 237 & 114  & 105  \\
$C_{2}$                      & 260   & 265 & 0   & 474 & 212 & 371 & 175  \\
$C_{3}$                     & 253    & 270 & 474 & 0   & 507 & 178 & 307  \\
$C_{4}$                      & 254    & 237 & 212 & 507 & 0   & 346 & 231  \\
$C_{5}$                      & 112    & 114  & 371 & 178 & 346 & 0   & 198  \\
$C_{6}$                      & 90    & 105 & 175 & 307 & 231 & 198 & 0    \\
\hline\noalign{\smallskip}
\end{tabular}
\label{table:ed}
\end{table}

As tarefas e a frota de veículos são detalhadamente descritos na Tabela \ref{table:jobvehicleinfo}. As informações sobre as tarefas definem a prioridade e urgência de suas entregas. Três veículos heterogêneos($V_1$, $V_2$ e $V_3$) são disponibilizados para transportá-las. 

\begin{table}
\centering
\caption{Jobs and vehicles detailed informations.}
\begin{tabular}{lllll|lll} 
\hline\noalign{\smallskip}
\multicolumn{1}{l}{Job} & $P_i$ & $d_i$  & $w_i$  & $s_i$ & \multicolumn{1}{l}{Vehicle} & $Q_k$  & $F_k$    \\ 
\hline
$J_1$                        & 25 & 266 & 1.8 & 20 & $V_1$                           & 204 & 1224  \\
$J_2$                        & 49 & 347 & 2.3 & 31 & $V_2$                           & 186 & 1116  \\
$J_3$                        & 36 & 303 & 4.3 & 25 & $V_3$                           & 160 & 960   \\
$J_4$                        & 96 & 431 & 4   & 86 &                              &     &       \\
$J_5$                        & 52 & 177 & 2   & 33 &                              &     &       \\
$J_6$                        & 43 & 315 & 4.6 & 42 &                              &     &       \\
\hline\noalign{\smallskip}
\label{table:jobvehicleinfo}
\end{tabular}
\end{table}

A Figura \ref{fig:ganttchart1} descreve visualmente a solução ótima para a instância. Neste exemplo, todos os três veículos foram utilizados durante a entrega, possuindo tempos
de início $S_1$,$S_2$ e $S_3$ iguais a 180, 301 e 88, respectivamente. A porcentagem no final de um trajeto representa o espaço ocupado pelas tarefas carregadas no veículo. 
Dentre as seis tarefas, apenas $J_6$ foi entregue sem atrasos.

\begin{figure}[ht]
	\centering
    \includegraphics[width=1\textwidth]{Images/VISUAL_REP2} 
    \caption[]{Gráfico de Gantt com a descrição visual da solução.}
  	\label{fig:ganttchart1}
\end{figure}


Na solução ótima da instância, os tempos de completude $C$ das tarefas são, respectivamente: 276, 180, 88, 301, 52 e 137. 

Os tempos de destino $D$, que indicam o momento em que o pedido chega àos clientes são: 328, 445, 378, 565, 200 e 270. 

No cálculo da diferença entre o tempo de destino e a o prazo de entrega, obtêm-se os seguintes valores de atraso $T$:  62, 98, 75, 134, 23 e 0.

O resultado ótimo da função objetivo possui valor absoluto $6127.5$,sendo composto por três partes integrantes do problema. A primeira, é dada pelos custos de trajeto dos três veículos, que são calculados em $DC = (112+178+253) + (90+175+260) + (27+237+254) = 1586$. 

A segunda parte é definida pelos custos de utilização de veículo, que neste contexto será total, uma vez que todos veículos foram utilizados. Desta forma, $VC =  1224+1116+960 = 3300$.

Os atrasos $T$ serão multiplicados por suas respectivas penalidades $w$.
Isto posto, o custo total de atrasos ponderados é $TC = (62*1.8) + (98*2.3) + (75*4.3) + (134*4) + (23*2) + (0*4.6) = 1241.5$.

Portanto, ao combinar as três parcelas da função objetivo, é obtido o valor final $DC + VC + TC = 6127.5$ na solução ótima da instância. 

\section{Geração de Instâncias}\label{instancesgen}

Por se tratar de uma variação do problema ainda não abordada na literatura, a criação de instâncias tornou-se necessária. As instâncias foram distruibuídas em dois grupos, instâncias pequenas e grandes. O primeiro varia entre oito e vinte tarefas, de três à seis veículos, e o segundo entre trinta e cem tarefas, de cinco à doze veículos.

Seja uma tarefa $i$ $\in$ $N$, seu tempo de processamento $P_{i}$ pertence um intervalo limitado:

\setcounter{equation}{0}
\begin{equation} 
\label{ins-P}
P_{i} \in rand[1,\rho], \quad with \quad \rho = 100
\end{equation}

Seu tamanho $s_i$  é relacionado ao tempo de processamento, também definido em um intervalo:

\begin{equation}
\label{ins-s}
s_{i} \in rand[1,P_{i}]
\end{equation}

A data de vencimento $d_i$ de uma tarefa deve possuir ligação entre seu tempo de processamento e a distância entre o cliente e a origem. Ela é determinada a partir de uma janela de tempo, que possui limite inferior $z_i$ e superior $\overline{z}_{i}$:
\begin{equation}
\label{ins-d}
 \begin{array}{l}
    d_{i} \in rand[z_{i},\overline{z}_{i}] \quad st. \\
    \begin{array}{l}
    				z_i = P_{i}+t_{0i}+\pi_1 \\
     			\quad \overline{z}_{i} = z_{i} + \pi_2\\
   			  \end{array}
 \end{array}
\end{equation}

Os parâmetros $\pi_1$ e $\pi_2$ influenciam na dificuldade da instância pois seus valores podem encurtar ou prolongar as janelas de tempo, resultando em prazos de entrega menores ou maiores:
\begin{equation}
\label{ins-pi}
 \begin{array}{l}
 	\pi_1 \in rand[0,\frac{\sum_{i=1}^N P_{i}}{K+1}]\\
 	\pi_2 \in rand[0,\delta*\rho]
 \end{array}
\end{equation}

O peso de penalidade $w_i$ é determinado de forma aleatória em um intervalo, sendo este parâmetro integrante da função objetivo:
\begin{equation}
\label{ins-w}
 w_{i} \in rand[1.0, 5.0]
\end{equation}
 A capacidade $Q$ dos veículos é dada de forma que a tarefa de maior tamanho possa ser transportada qualquer um destes, somado à um valor relacionado a média de todos tamanhos pela quantidade de veículos:
 
\begin{equation}
\label{ins-Q}
	\begin{array}{l}
    		Q_{k} = max_{i=1}^N\{s_{i}\} + \tau \quad st.\\
  		\tau \in rand[{\frac{\sum_{i=1}^N s_{i}}{K}},\mu*{\frac{\sum_{i=1}^N s_{i}}{K}}]\\ 
	\end{array}
\end{equation}

O custo $F_k$ de um veículo $k$ é diretamente proporcional à sua capacidade:
\begin{equation}
\label{ins-Q}
    F_{k} = N*Q_{k}
\end{equation}
    
   
To determine the travel time $t_{ij}$ between two customers, first we have to generate the origin's coordinates.
The machine's coordinates $(x_0,y_0)$ are generated subject to the following range:\\ 
\begin{equation}
\label{ins-origin}
x_{0},y_{0} \in  rand[400,700]
\end{equation}
Após fixadas as coordenadas da origem. são geradas as coordenadas dos clientes de forma que estejam no primeiro quadrante e sua distância euclidiana (ED) até a origem respeite a seguinte constante:
\begin{equation}
\label{ins-customers}
\begin{array}{l}
    (x_{i},y_{i}) \geq (0,0) \quad \forall i=1,...,N\\
    ED((x_0,y_0), (x_i,y_i)) \leq (\rho * K) \quad \forall i=1,...,N
\end{array}
\end{equation}

Por fim, são indicados os parâmetros utilizados nas equações acima ($\delta$,$\mu$, $N$ and $K$). Para cada um dos conjuntos de instâncias (small e large), existe uma definição diferente dos valores dos parâmetros, que influenciará na dificuldade da resolução do problema. 

Para instâncias pequenas, os valores definidos para $\mu$, $N$ and $K$ são:
\begin{equation}
\label{ins-small-parameters}
	\begin{array}{ll}
		\mu \in \{1, 1.5, 2.0\}\\
		N \in \{8,10,15,20\}\\
		K \in \{3,4,5, 6\}\\
	\end{array}
\end{equation}

Para instâncias maiores, após realizados os ajustes dos três parâmetros, estes foram definidos em:
\begin{equation}
\label{ins-large-parameters}
	\begin{array}{lll}
		\mu \in \{1.5, 2.0, 2.5\}\\
		N \in \{50,80,100\}\\
		K \in \{5,8,10,12\}\\
	\end{array}
\end{equation}
A constante $\delta$ utilizada para calcular o limite superior de $d_i$ (Equação \ref{ins-pi}), assume os seguintes valores para ambos conjuntos de instâncias:
\begin{equation}
	\delta \in \{0.5, 1.0, 1.5, 2.0, 2.5\}
\end{equation}

Definidos os parâmetros, para cada combinação ($\delta$,$\mu$, $N$ and $K$) foram geradas cinco instâncias pequenas e três instâncias grandes, totalizando (5*3*4*4*5) + (3*3*3*4*5) = 1740 instâncias.

\section{Busca Local e Vizinhanças}\label{nboperators}

O processo de busca local visa aprimorar uma solução atual ao considerar soluções similares pelas operações de vizinhança definidas. Neste trabalho, são consideradas apenas soluções viáveis no processo. Portanto, todas as soluções em que a soma dos tamanhos das tarefas exceda a capacidade de transporte de um veículo serão desconsideradas. Matematicamente, uma solução $S$ é descartada se:
\begin{equation}\\
 \label{eq:invalidsol}
Q_{k} < \sum\limits_{i=1}^{|N_k|} s_{i};  \forall k \in K;
\end{equation} 

Para constituir o conjunto de vizinhanças de uma solução, estas foram subdivididas em dois subconjuntos: vizinhanças Intra-Rota e Inter-Rota. 


\subsection{Vizinhanças Intra-Rota}\label{intraroutenb}
Neste subconjunto, as operações aplicadas para diversificação da solução são restritas a alterações internas de um veículo, influenciando somente na ordem de entrega das tarefas carregadas por este. Seja $R$ uma solução viável para o problema e $R_{i}$ a rota completa de um veículo $i$. São definidas as operações:

\begin{itemize}
  \item \textbf{Swap-Adj-Job}($R_{i}$) — Troca de posição duas tarefas adjacentes na rota $R_{i}$. \\
  
  \item \textbf{Insert-Job}($R_{i}$) — Insere uma tarefa nas demais posições da rota $R_{i}$.\\
  
  \item \textbf{2-opt}($R_{i}$) — Realiza a operação de 2-opt em todas combinações de arcos distintos da rota $R_{i}$, i.e., seleciona dois arcos distintos, os remove e reconecta os clientes de forma que a rota seja modificada e permaneça interligada.
\end{itemize}

\subsection{Vizinhanças Inter-Rota}\label{interroutenb}

As operações de vizinhança do tipo Inter-Rota consideram duas ou mais rotas durante sua aplicação, realizando alterações em mais de uma rota ao mesmo tempo. Durante o processo, as operações aplicadas podem gerar soluções inviáveis, porém estas não serão consideradas neste trabalho.

Seja $R$ uma solução viável para o problema e $R_{i}$ e $R_{w}$ as rotas completas realizadas pelos veículos $i$,$w$ $\in$ $K$. Ademais, o conjunto de tarefas carregadas por um veículo $i$ é representado por $N_i$. São definidas as operações:
\begin{itemize}
\item \textbf{Swap-Job}($R_{i}$, $R_{w}$) — Trocam de posição duas tarefas $a$ $\in$ $N_{i}$ e $b$ $\in$ $N_{w}$ entre as duas rotas, de forma que $a$ receberá a posição antiga de $b$ na nova rota e vice-versa.\\ 

\item \textbf{Insert-Job}($R_{i}$, $R_{w}$) — Insere uma tarefa $a$ $\in$ $N_{i}$ nas demais posições da rota $R_{w}$.\\

\item \textbf{Swap-Adj-Vehicles}($R_{i}$, $R_{w}$) — Trocam de posição dois veículos adjacentes $i$ e $w$ carregando consigo seus lotes de tarefas, i.e., caso o veículo $i$ agora parta após o veículo $w$, o primeiro ($i$) deverá esperar todas as tarefas do segundo ($w$) sejam processadas para que as suas se iniciem na máquina.\\

\item \textbf{Insert-Vehicle}($R_{i}$) — Insere um veículo $i$ juntamente com suas tarefas atreladas ($N_i$) nas demais posições da solução, i.e., insere seu lote de tarefas antes, entre ou após outros veículos.\\
\end{itemize}

\subsection{Abordagens de RVND}\label{rvndapproaches}

O processo de busca local é realizado por VND (Mladenovic and Hansen 1997)\cite{mladenovic1997variable}, utilizando sete operadores de vizinhança e ordenação aleatória de vizinhanças (RVND). São empregadas duas versões de RVND, com técnicas diferentes de organização dos operadores.

A primeira versão, descrita em Algorithm \ref{algo:rvnd}, consiste de percorrer aleatoriamente pelo conjunto de vizinhanças à procura de melhorias na solução atual, e em seguida reiniciar este procedimento quando alguma melhora é alcançada. Do contrário, caso nenhuma melhoria seja obtida na execução, a busca local é encerrada.
O algoritmo possui um único parâmetro: uma solução $S$, e se inicia atribuindo $S$ à melhor solução encontrada $S*$ (Passo 1).

\begin{algorithm}
\label{algo:rvnd}
\AlFnt \small
\LinesNumbered
\Input{Solution $S$}
\Output{Better or equal $S*$ solution}
  \caption{RVND($S$)}
  
  $S* \gets S;$\\
  $NeighborhoodSet \gets$\textup{Random Order($Neighborhoods$);}\\
  \For{$i \gets$ \textup{1 in} $NeighborhoodSet$}{
        $currNeighborhood \gets NeighborhoodSet[i];$ \tcp{Select Neighborhood}
        $S \gets$ \textup{currNeighborhood(S)}; \tcp{Apply Local Search}
        \If{\textup{f($S$) $\leq$ f($S*$)}}{
            {$S* \gets S;$\\
            $NeighborhoodSet \gets$\textup{Random Order($Neighborhoods$);}\\
            $j \gets 1;$ \tcp{Restart Local Search}
            }
        }
         
    }
  \Output{$S*$}
\end{algorithm}

 Em seguida, todo o conjunto de vizinhanças é distribuido em ordem aleatória em $NeighborhoodSet$ (Passo 2). Todas as vizinhanças em $NeighborhoodSet$ são visitadas na ordem sorteada (Passos 3-10) e seus vizinhos $S$ são comparados à melhor solução $S*$ (Passos 5-6). Caso algum vizinho seja satisfatório, ele é então salvo em $S*$ (Passo 7) e o processo de busca é reiniciado com nova ordem aleatória (Passos 8-9), caso contrário o algoritmo termina. A melhor solução $S*$ encontrada na busca local é retornada.



A segunda versão, RVND-Custom,  é baseada na técnica de aprimoramento interno (Penna and Ochi, 2013)\cite{penna2013iterated}, onde as vizinhanças externas à uma rota Inter-Route Neighborhoods são analisadas, e caso seja obtida melhora na solução, as vizinhanças internas Intra-Route Neighborhoods são acionadas para a aprimorar ainda mais. A aplicação é descrita em Algorithm \ref{algo:rvnd2}. 

O algoritmo possui um parâmetro: uma solução $S$, e é iniciado ao atribuir $S$ à melhor solução encontrada $S*$ (Passo 1). Em seguida, o conjunto de vizinhanças Inter-Rota é randomicamente distribuido e armazendo em $InterRoute$ (Passo 2). Todos as vizinhanças são visitadas na ordem sorteada (Passos 3-22), sendo seus vizinhos $S'$ analisados (Passos 4-5) e caso sejam melhores do que $S$, o aprimoramento interno de rota se inicia (Passos 6-18). 

\begin{algorithm}
\label{algo:rvnd2}
\AlFnt \small
\LinesNumbered
\Input{Solution $S$}
\Output{Better or equal $S*$ solution}
  \caption{RVND-Custom($S$)}
  
  $S* \gets S;$\\
  $InterRoute \gets$\textup{Random Order($Inter$-$Route$ $Neighborhoods$);}\\
  \For{$i \gets$ \textup{1 in} $InterRoute$}{
         $currInter \gets InterRoute[i];$ \tcp{Get Inter-Route Neighborhood}
         $S' \gets$ \textup{currInter(S)}; \tcp{Apply Inter Local Search}
         \If{\textup{f($S'$) $\leq$ f($S$)}}{
               {$IntraRoute \gets$\textup{$Intra$-$Route$ $Neighborhoods$;}\\
                 \For{$j \gets$ \textup{1 in} $IntraRoute$}{
                    $currIntra \gets IntraRoute[j];$\tcp{Apply Intra Local Search}
                    $S'' \gets currIntra(S');$\\ 
                     \If{\textup{f($S''$) $\leq$ f($S'$)}}{
                        $S' \gets S'';$\\
                        $j \gets 1;$ \tcp{Restart Intra-Route Socal Search}
                     }
                 }
                }
                $i \gets 1;$\\
                $InterRoute \gets$\textup{Random Order($Inter$-$Route$ $Neighborhoods$);}\\
            }
         \If{\textup{f($S'$) $\leq$ f($S*$)}}{
                {$S* \gets S'$;\\}
            }
    }
  \Output{$S*$}
\end{algorithm}

Em seguida, o conjunto de vizinhanças Intra-Rota é visitado sequencialmente (Passos 8-15) e na hipótese de melhorar novamente (Passos 11-14), a busca interna se reinicia (Passo 13). Do contrário, esta termina e a busca externa é reiniciada com nova ordem aleatória (Passos 16-17). 
A melhor solução encontrada é atualizada a cada iteração da busca externa (Passos 19-21). Ao final do algoritmo, a melhor solução $S*$ é retornada.


\section{Abordagens de Solução}\label{solutionapproach}

Neste trabalho são propostos três algoritmos para solucionar o Problema de Sequenciamento de Produção e Entrega: dois algoritmos de Iterated Local Search (ILS) e um Algoritmo Genético (G.A.). 

O primeiro algoritmo de Iterated Local utiliza a implementação básica de RVND e o segundo utiliza o modelo de RVND customizado com a técnica de aprimoramento interno de rotas (Penna and Ochi, 2013 \cite{penna2013iterated}). O Algoritmo Genético (GA) desenvolvido contém método de Torneio Binário e mutação em 2-point Crossover. 

\subsection{Soluções Iniciais}\label{initialsolutions}

A qualidade de um ótimo local obtido por método de busca local depende da solução inicial trabalhada (El-Ghazali Talbi, 2009)\cite{talbi2009metaheuristics}. As regras para a criação de soluções iniciais utilizadas aqui originam-se do problema de Permutation Flow Shop, sendo estas Apparent Tardiness Cost (ATC), Weighted Modified Due Date (WMDD) e Weighted Earliest Due Date (EDD) (Molina-Sánchez and González-Neira, 2015)\cite{molina2016grasp}.


\begin{equation}
    \label{eq:atc}
    ATC_i \quad = \quad \frac{ w_i}{P_i} * \exp(- \frac{max(d_i-P_i-t, 0)}{ \frac{\sum_{i=1}^N P_{i}}{N} })
\end{equation}

\begin{equation}
    \label{eq:atc}
    ATC_i \quad = \quad \frac{ w_i}{P_i} * \exp(- \frac{max(d_i-P_i-t, 0)}{ \overline{P}})
\end{equation}

\begin{equation}
    \label{eq:atc}
    ATC_i \quad = \quad \frac{ w_i}{P_i} * \exp(- max(d_i-P_i-t, 0) / \overline{P})
\end{equation}

\begin{equation}
    \label{eq:wmdd}
    WMDD_i \quad = \quad \frac{ 1}{w_i} * max(P_i, d_i - t))
\end{equation}
\begin{equation}
    \label{eq:wedd}
    WEDD_i \quad = \quad \frac{d_i}{w_i} 
\end{equation}

O conjunto de regras têm por objetivo designar uma ordem favorável para o sequenciamento de tarefas. Por se tratar de uma Frota Heterogênea de Veículos, a ordem gerada pelas regras pode ou não ser atendida devido às restrições de capacidade dos veículos. Caso nenhuma das três regras gere sequência viável, uma solução inicial aleatória é utilizada.


\section{Iterated Local Search}\label{ils}

Ao gerar variados ótimos locais, utilizar a Iterated Local Search torna possível obter aprimoramento da qualidade da solução (Talbi, 2009)\cite{talbi2009metaheuristics}. Neste artigo em específico, as aplicações de Iterated Local Search utilizam duas versões de busca local RVND.

Os métodos de perturbação do algoritmos descritos em seguida utilizam os operadores de vizinhança Inter-Rota: \textbf{Swap-Job}($R_{i}$, $R_{w}$) e \textbf{Insert-Job}($R_{i}$). É realizada uma quantidade $\alpha$ de perturbações, sendo $\alpha$ estatisticamente definido na Seção ‘Calibração de Parâmetros’. %Completar com a seção%

\subsection{ILS-RVND}
O esquema geral da metaheurística ILS proposta é apresentado em Algoritmo \ref{algo:ilsrvnd}. Existem três parâmetros: $\alpha$ (número de perturbações), $MaxIter$ (quantidade de reinícios de solução) e $MaxIterILS$ (máximo de iterações consecutivas para o algoritmo). Inicialmente, a variável de melhor solução global é inicializada (Passo 1). 

A cada iteração externa, uma nova solução inicial $S$ é gerada (Passo 3) utilizando as regras descritas na Seção \ref{initialsolutions}, e em seguida é feito busca local em $S$ (Passo 4). Após sua possível melhora, o processo de Perturbação é inicializado (Passos 5-12), a solução atual $S’$ é perturbada $\alpha$ vezes (Passo 10), é feito busca local RVND (Passo 11) e a melhor solução encontrada é atualizada (Passos 6-9).

\begin{algorithm}
\label{algo:ilsrvnd}
\AlFnt \small
\LinesNumbered
\Input{Parameters of max. iterations numbers}
\Output{Best solution $S*$}
  \caption{ILS-RVND ($ \alpha, MaxIter,MaxIterILS$)}
  
  $S* \gets$ Initialize($S*$);\\
  
  \For{$i \gets$ \textup{1 to} $MaxIter$}{
  
         $S \gets $ \textup {GenerateInitialSolution();}\\
         $S' \gets$ \textup{RVND($s$)};\\
         
        \For{$j \gets$ \textup{1 to} $MaxIterILS$}{
         
            
            \If{\textup{f($S$) $\leq$ f($S'$)}}{
                {$S'\gets S$;\\
                $j \gets 1;$ \tcp{Restart Perturbing Process}}
            }
            
            $S' \gets $\textup{Perturb($S'$, $\alpha$)};\\
            $S' \gets $\textup{RVND($S'$)}; \tcp{Local Search on Perturbed S'}
         }
         
         \If{\textup{f($S'$) $\leq$ f($S*$)}}{
                {$S* \gets S'$;\\}
            }
    }
  \Output{$S*$}
\end{algorithm}

\begin{algorithm}
\label{algo:ilsrvnd}
\AlFnt \small
\LinesNumbered
\Input{Parameters of max. iterations numbers}
\Output{Best solution $S*$}

  \caption{ILS-RVND ($ \alpha, MaxIter,MaxIterILS$)}
  
  $S* \gets \infty $;\\
  
  \For{$i \gets$ \textup{1 to} $MaxIter$}{
  
         $S' \gets $ \textup {Initial-Solution();}\\
         
        \For{$j \gets$ \textup{1 to} $MaxIterILS$}{
        
            $S' \gets $\textup{RVND($S'$)}; 
            
            \If{\textup{f($S'$) $<$ f($S*$)}}{
                {$S* \gets S'$;\\
                $j \gets 1;$ \tcp{Restart Perturbing Process}}
            }
            
            $S' \gets $\textup{Perturb($S'$, $\alpha$)};\\
         }
         
         \If{\textup{f($S'$) $<$ f($S*$)}}{
                {$S* \gets S'$;\\}
            }
    }
  \Output{$S*$}
\end{algorithm}


Caso alguma melhora em $S’$ em  relação à solução inicial $S$ seja obtida, o processo de Perturbação é reinicializado (Passo 8). Nos Passos 13-15, $S’$ é comparada a melhor solução $S*$ e finaliza uma iteração do algoritmo. Ao final é retornada a melhor solução encontrada $S*$.

\subsection{ILS-RVND com Aprimoramento de Rota Interna}\label{ilsrvnd2}

Penna and Ochi, 2013 \cite{penna2013iterated} desenvolveram o primeiro modelo de Iterated Local Search com RVND para o Problema de Roteamento de Frota Heterogênea de Veículos (HFVRP) em um ambiente com até cem clientes, e produziram resultados competitivos com aos da literatura. Sua abordagem em lidar com a entrega de mercadorias em específico serviu de inspiração para esta combinação ILS-RVND.

A diferença desta versão de Iterated Local Search para a anterior está na busca local RVND-Custom, que utiliza a técnica de aprimoramento interno de rotas. O pseudocódigo desta aplicação é derivado do Algoritmo \ref{algo:ilsrvnd} ao realizar a substituição referida em Figura \ref{fig:ilsdif}.

\begin{figure}[ht]
	\centering
    \includegraphics[scale=0.072]{Images/ILS_DIF} 
    \caption[]{Mudança entre acionamentos de RVND.}
  	\label{fig:ilsdif}
\end{figure}

Nesta técnica, assim que uma solução atual é aperfeiçoada utilizando operadores externos às rotas, como realizar intercâmbio de tarefas entre veículos, os operadores internos às rotas são acionados.

\section{Algoritmo Genético}\label{genalgo}

Algoritmos Genéticos foram desenvolvidos por J. Holland em meados dos anos 70 (University of Michigan, USA)  para entender o processo adaptativo de sistemas naturais (Talbi, 2009)\cite{talbi2009metaheuristics}. Nesta abordagem, são utilizadas técnicas de Torneio Binário para seleção de soluções e 2-point Crossovers para diversificação da prole. O esquema geral do algoritmo é descrito em Algorithm \ref{algo:genalgo}.

Existem dois parâmetros: $PopSize$ (quantidade de indivíduos na população) e $MaxIter$ (número de iterações em que serão geradas novas populações. O algoritmo é iniciado no Passo 1 ao gerar uma população aleatória $P$, seguido de uma busca local RVND em $P$ (Passo 2). A melhor solução da população é armazenada em $P*$ (Passo 3). 

A cada iteração uma nova solução é inserida em $P'$ até o limite de $PopSize-1$ indivíduos (Passos 6-22). Para gerar uma prole, são escolhidas duas soluções ‘pai’ por Torneios Binários (Passos 7-8), e em seguida são geradas duas mutações destas soluções (Passos 9-10). 


\begin{algorithm}
\label{algo:genalgo}
\AlFnt \small
\LinesNumbered
\Input{Population size and max. iteration number}
\Output{Best solution $P*$ in $MaxIter$ populations}
  \caption{Genetic Algorithm ($PopSize,MaxIter$)}
  
  $P \gets$ \textup{Generate random population($PopSize$);}\\
  $P \gets$ \textup{ RVND($P$);} \tcp{Apply local search to new population P}
  $P* \gets$ \textup{Best($P$);} \tcp{Save best solution of P}
  
  \For{$i \gets$ \textup{1 to} $MaxIter$}{
        $P'  \gets$ \text {\O;}\\
          
        \For{$j \gets$ \textup{1 to} $(PopSize-1)$}{
          
            $Parent1 \gets$ \textup{Binary Tournament(random($P$), random($P$));}\\
            $Parent2 \gets$ \textup{Binary Tournament(random($P$), random($P$));}\\
         
            $Offspring1  \gets$ \textup {Crossover($first, second$); }\\
            $Offspring2 \gets$ \textup {Crossover($first, second$); }\\
         
            \eIf{ \textup{Feasible($Offspring1$) and Feasible($Offspring2$) } }{
          
                \textup{$P' \gets P'$ + BinaryTournament($Offspring1,Offspring2$);}
                
            }{\eIf{ \textup{Feasible($Offspring1$) or  Feasible($Offspring2$)} }{
          
                \textup{$ P' \gets P'$ + Feasible from($Offspring1,Offspring2$);}
                
            }{ 
                \If{\textup{!Feasible($Offspring1$) and !Feasible($Offspring2$) } }{
              
                    \textup{ $P' \gets P'$ + Mutation(random($Parent1,Parent2$));\\}
                    
                }
            }
            }
        }
        $ P' \gets$ P' + P*; \tcp{Include best solution to P'}
        $ P' \gets$ \textup{ Fast Local Search($P'$);} \tcp{Fast Local Search in population P'}
        \If{\textup{ f(Best($P'$)) $\leq$ f($P*$)  } }{
            \textup{$P* \gets Best($P'$)$;\\}
        }
        
        $ P \gets$ \text { $P';$} \\
  }
  \Output{$P*$}
\end{algorithm}

O processo de mutação Crossover pode produzir soluções inviáveis, dessa forma a escolha de uma nova solução para a população $P’$ necessita de análise:

\begin{itemize}
  \item No primeiro caso, em que as duas novas mutações são viáveis, estas participam de um Torneio Binário (Passo 12) e a escolhida será adicionada à população.
  \item No segundo caso, onde apenas uma das soluções é viável, a única prole viável será inserida na população $P’$ (Passo 15).
  \item No último caso, se as duas mutações geradas são inviáveis (Passo 17), uma escolha aleatória entre as soluções ‘pai’ é feita e sofrerá uma nova mutação Crossover (Passo 18), sendo adicionada em seguida.
\end{itemize}  
	Após a obtenção de $PopSize-1$ indivíduos em $P’$, é inserida a melhor solução $P*$ encontrada até o momento (Passo 23). Com a população completa, é realizada uma busca local rápida (Passo 24) em todos os indivíduos. Este método é descrito na Seção \ref{algo:fastlocalsearch}.
Por fim, a melhor solução $S*$ é atualizada (Passos 25-26) e a população $P’$ torna-se a população atual $P$, para nas próximas iterações gerar novos indivíduos (Passo 25).

\subsection{Busca Local Rápida}\label{fastlocalsearch}

Nesta seção é descrito um procedimento de busca local chamado Fast Local Search. Métodos de busca local convencionais como VND e RVND podem ser computacionalmente custosos acionados consecutivas vezes, apesar de possibilitarem melhoras significativas na qualidade da solução. Dessa forma, foi implementado um método de busca local simples para lidar com as soluções do algoritmo populacional. O procedimento é descrito em  Algoritmo \ref{algo:fastlocalsearch}.

\begin{algorithm}
\label{algo:fastlocalsearch}
\AlFnt \small
\LinesNumbered
\Input{Solution $S$}
\Output{Better or equal $S*$ solution}
  \caption{Fast Local Search($S$)}
  
  $S* \gets S;$\\
  $NeighborhoodSet \gets$\textup{$Inter$-$Route$ and $Intra$-$Route$ $Neighborhoods$;}\\
  \For{$i \gets$ \textup{1 to} $NeighborhoodSet$}{
  
         $currNeighborhood \gets NeighborhoodSet[i]$;\\
         $S' \gets$ \textup{currNeighborhood(S)};\\
       
         \If{\textup{f($S'$) $\leq$ f($S*$)}}{
                {$S* \gets S'$;\\}
            }
    }
  \Output{$S*$}
\end{algorithm}

O algoritmo possui um parâmetro: uma solução $S$ e se inicia ao atribuir $S$ à melhor solução global $S*$ (Passo 1). Todo o conjunto de vizinhanças (Inter-Rota e Intra-Rota) é atribuido à $NeighborhoodSet$ (Passo 2). Em seguida, o método percorre sequencialmente as vizinhanças em $NeighborhoodSet$ (Passos 3-8) e analisa seus vizinhos (Passos 4-5). Em cada vizinhança, a melhor solução $S'$ da vizinhança é comparada com a melhor solução global e $S*$ é atualizada (Passos 6-8).
Por fim, o método de busca local retorna a melhor solução encontrada.



\section{Experimentos Computacionais}\label{experiments}


%All the heuristic algorithms were coded in C++ and executed on a PC machine IntelR Core TM i7-4790K CPU @ 4.00GHz x 8 with 32GB RAM, running Ubuntu 14.04 LTS 64 bits. The quality of the solutions were measured by the relative percentage deviation (RPD) from the best known solution (reference solution). The RPD measure represents the percentage of how much experimental results differs from a reference value, and is calculated following the equation: 
%\begin{equation}\label{eq:rpd}
%RPD(\%)= 100 \times \frac{TT_{\mbox{experimental}} - TT_{\mbox{reference}}}{TT_{\mbox{reference}}}
%\end{equation}
%where $TT_{\mbox{reference}}$ is the value of the reference solution, and %$TT_{\mbox{experimental}}$ is the obtained solution by  a given heuristic. 

Nesta Seção são apresentados os experimentos realizados em cima dos três algoritmos e o software CPLEX.
Todos os algoritmos foram codificados em C++ e executados em uma máquina Intel(R) Core TM i7-4790K CPU @ 4.00GHz x 8 with 32GB RAM, rodando Ubuntu ??.?? 64 bits. 

A métrica de comparação utilizada é o desvio relativo percentual (RPD), sendo utilizada o melhor resultado entre os algoritmos ($f_{best}$) para a comparação entre elas. O RPD(\%) mede percentualmente o quanto os resultados experimentais ($f_{method}$) diferem do valor de referência:

\begin{equation}
\label{rpd}
	RPD = \frac{f_{method} - f_{best} }{ f_{best}} * 100\%
\end{equation}

Também são utilizadas as métricas Average RPD(\%) e Best RPD(\%), onde a primeira utiliza o $f_{method}$ como sendo a média dos resultados das execuções e a segunda como o melhor resultado dentre as execuções.
A performance das heurísticas aplicadas foram testadas em todas as 1740 instâncias. 

As siglas para as heurísticas nesta seção foram definidas de forma que 'ILS-RVND-1' se refira à heurística ILS RVND, 'ILS-RVND-2' à heurística ILS RVND com Aprimoramento de Rota Interna e por fim 'GA-LS' ao Algoritmo Genético.


\subsection{Calibração de Parâmetros}\label{parameters-calibration}

Nesta Seção, testes preliminares são apresentados para definir os parâmetros de execução dos três algoritmos.

O primeiro algoritmo, ILS$\_$RVND$\_$1, utiliza três parâmetros: o número de perturbações $\alpha$, o número máximo de reinícios do algoritmo $MaxIter$ e o máximo de iterações da ILS $MaxIterILS$. Foram definidos no conjunto de testes os seguintes valores: $\alpha \in \{2,5,8,10\}$, $MaxIter \in \{5,8,10\}$  e $MaxIterILS \in$ $\{50,100\}$.
Dessa forma, foram geradas 24 combinações de parâmetros, sendo cada uma delas executada 10 vezes para as 1740 instâncias. 
%response variable%

	Os resultados foram analisados por meio do teste não-paramétrico de Kruskall-Wallis utilizando  o Average RPD(\%) como variável de resposta. Seguindo a Equação \ref{rpd}, a variável $f_{method}$ foi definida como sendo o resultado da combinação para a instância e $f_{best}$ como o melhor resultado obtido dentre todas combinações.
	No teste de Kruskall-Wallis duas hipóteses são testadas: a hipótese nula afirma que a performance de todas implementações testadas são estatisticamente similares, e a hipótese alternativa conclui que pelo menos uma implementação possui performance significativamente diferente. Na Figura \ref{fig:calib-algo1}, os intervalos médios de confiança são apresentados à 95\% de confiança.

\begin{figure}[ht]
	\centering
    \includegraphics[width=1\textwidth]{Images/calibration/general rpd calib ilrs-rvnd-1 int} 
     \caption[]{Mean plot and confidence intervals at 95\% confidence level for ILS$\_$RVND$\_$1 experiment.}
  	\label{fig:calib-algo1}
\end{figure}

	Intervalos que se sobrepõem sugerem que pode não haver diferença entre as implementações. Os  intervalos '8-100-5' e '10-100-5' se sobrepuseram e apresentaram com menor média. Pelo teste de Kruskall-Wallis, o p-valor=$0.00 \leq 0.05$ obtido indica que a hipótese nula deve ser rejeitada, concluindo assim que pelo menos uma implentação tem performance significativamente diferente (hipótese alternativa). A combinação '10-100-5' foi escolhida por apresentar o melhor intervalo.
	
De forma análoga, para o segundo algoritmo ILS$\_$RVND$\_$2, foram utilizadas as 24 combinações de parâmetros acima e em seguida executadas 10 vezes em cada instância. As combinações que possuiam menor o número de perturbações $\alpha$ obtiveram destaque (Figura \ref{fig:calib-algo2}).

\begin{figure}[ht]
	\centering
    \includegraphics[width=1\textwidth]{Images/calibration/general rpd calib ilrs-rvnd-2 int} 
     \caption[]{Mean plot and confidence intervals at 95\% confidence level for ILS$\_$RVND$\_$2 experiment.}
  	\label{fig:calib-algo2}
\end{figure}

 As duas menores médias '8-100-2' e '10-100-2' não se sobrepuseram nos intervalos de confiança, indicando que há diferenças entre as implementações. Ademais, com o p-valor=$0.00 \leq 0.05$, a hipótese alternativa é novamente válida e há pelo menos uma implementação com  performance significamente diferente. Isto posto, foi definida a combinação '10-100-2' para o algoritmo.

O terceiro algoritmo, GA$\_$LS, utiliza dois parâmetros: $PopSize$ e $MaxIter$, o tamanho da população e o número máximo de iterações, respectivamente.  Os conjuntos de valores destes parâmetros foram definidos em $PopSize \in \{30,50,70\}$ e $MaxIter \in \{5,8,10\}$. São geradas 9 combinações de parâmetros e foram executadas em todas as instâncias.

\begin{figure}[ht]
	\centering
    \includegraphics[width=1\textwidth]{Images/calibration/general rpd calib ga-ls int} 
      \caption[]{Mean plot and confidence intervals at 95\% confidence level for GA$\_$LS experiment.}
  	\label{fig:calib-algo3}
\end{figure}

Novamente, pelo teste de Kruskall-Wallis, o p-valor=$0.00 \leq 0.05$ obtido indica a validade da hipótese alternativa. Os intervalos de confiança são mostrados na Figura \ref{fig:calib-algo3}. As melhores médias '70-5', '70-8' e '70-10' tiveram seus intervalos sobrepostos, o que indica que são estatisticamente equivalentes. Portanto, foi escolhida a combinação '70-5' por executar em menor tempo do que as demais ao possuir um número menor de iterações.


\subsection{Resultados em Instâncias Pequenas}\label{small-instances-results}

Em instâncias pequenas, os resultados das heurísticas foram comparados entre si e aos resultados do software CPLEX. Para o software, foi definido o tempo limite de execução de $t_{max} = 3600s$. Para $N = 8$, tanto as heurísticas quanto o software atingiram a solução ótima. Dessa forma, as análises nesta Seção tratam as instâncias em que $N \in \{10,15,20\}$. Todas as três heurísticas foram executadas cinco vezes para cada uma das 1200 instâncias pequenas, e o software CPLEX uma única vez. 

A performance de cada algoritmo é medida pelo Average RPD(\%) seguindo a Equação \ref{rpd}, onde $f_{best}$ é o melhor resultado encontrado pelos quatro algoritmos, e $f_{method}$ como sendo a média das cinco execuções da heurística para cada instâncias. Como o software CPLEX foi executado uma vez, $f_{method}$ é o resultado desta execução.

Os resultados para as quatro implementações foram analisados pelo teste de Kruskall-Wallis. O p-valor=$0.00 \leq 0.05$ obtido indica que ao menos uma das implementações é significativamente diferente. Na Figura \ref{graphics:small} são plotados os valores de Average RPD(\%) das instâncias agrupadas pelo número de tarefas, e por último um gráfico geral de todas intâncias.


\begin{figure}
\centering     %%% not \center
\makebox[\textwidth][c]{
\subfigure[Average RPD with $N = 10$]{\label{fig:a}\includegraphics[width=78mm]{Images/small-instances/avg 10 jobs int}}
\subfigure[Average RPD with $N = 15$]{\label{fig:b}\includegraphics[width=78mm]{Images/small-instances/avg 15 jobs int}} 
}
\makebox[\textwidth][c]{
\subfigure[Average RPD with $N = 20$]{\label{fig:c}\includegraphics[width=78mm]{Images/small-instances/avg 20 jobs int}} 
\subfigure[General Average RPD]{\label{fig:d}\includegraphics[width=78mm]{Images/small-instances/general avg rpd int}} 
}
\caption{Gráfico médio e intervalos de confiança com nível de confiança de 95\% para instâncias de pequeno porte.}
\label{graphics:small}
\end{figure}

É perceptível o distanciamento dos resultados do software CPLEX a medida em que o número de tarefas aumenta. Os algoritmos ILS$\_$RVND$\_$1 e GA$\_$LS obtiveram seus intervalos sobrepostos para $N=10$ e $N=15$, indicando que suas implementações são estatisticamente equivalentes para estes grupos. No gráfico geral, o algoritmo ILS$\_$RVND$\_$1 obteve a melhor média, seguido pelas heurísticas GA$\_$LS, ILS$\_$RVND$\_$2 e então CPLEX.

Na Tabela \ref{table:small-results}, as instâncias são agrupadas pelo número de tarefas $N$ e pelo número de veículos $K$, e seus resultados avaliados pelo Best RPD(\%) e Average RPD(\%). Nesta tabela, é possível observar a qualidade das soluções ao aumentar o número de clientes e veículos. Os resultados retratam o cenário apresentado acima, onde a heurística ILS$\_$RNVD$\_$1 possui a menor média geral. Este algoritmo disputa os melhores resultados com o Algoritmo Genético GA$\_$LS em 66,67\% dos grupos, e possui a média para o Best RPD(\%) quando comparada à heurística GA$\_$LS para $N=20$ e $K=6$.



\begin{table}
\centering
\caption{Best RPD and Avg. RPD analyisis over small instances.}
\begin{tabular}{ccccccccc}
	\hline\noalign{\smallskip}
	& \multicolumn{2}{c}{ILS$\_$RVND$\_$1} & \multicolumn{2}{c}{ILS$\_$RVND$\_$2} & \multicolumn{2}{c}{GA$\_$LS} & \multicolumn{2}{c}{CPLEX}\\
	\cline{2-9}\noalign{\smallskip}
	N x K & Best & Avg. & Best & Avg.  & Best & Avg. & Best  \\
	\hline
	\noalign{\smallskip}
10 x 3 & 0.00 & 0.01 & 0.00 & 0.04 & 0.00 & 0.00 & 0.45  \\
\noalign{\smallskip}
10 x 4 & 0.00 & 0.00 & 0.02 & 0.04 & 0.00 & 0.00 & 0.36\\
\noalign{\smallskip}
10 x 5 & 0.00 & 0.00 & 0.00 & 0.05 & 0.00 & 0.00 & 0.38\\
\noalign{\smallskip}
10 x 6 & 0.00 & 0.00 & 0.01 & 0.05 & 0.00 & 0.00 & 0.35 \\
\noalign{\smallskip}
15 x 3 & 0.00 & 0.00 & 0.70 & 1.96 & 0.00 & 0.05 & 5.98  \\
\noalign{\smallskip}
15 x 4 & 0.00 & 0.01 & 0.21 & 0.77 & 0.00 & 0.04 & 5.07 \\
\noalign{\smallskip}
15 x 5 & 0.00 & 0.02 & 0.41 & 0.90 & 0.03 & 0.06 & 3.64  \\
\noalign{\smallskip}
15 x 6 & 0.00 & 0.00 & 0.27 & 0.60 & 0.00 & 0.03 & 3.75  \\
\noalign{\smallskip}
20 x 3 & 0.00 & 0.06 & 3.76 & 5.86 & 0.07 & 0.29 & 21.28 \\
\noalign{\smallskip}
20 x 4 & 0.00 & 0.05 & 2.68 & 4.50 & 0.09 & 0.35 & 21.28 \\
\noalign{\smallskip}
20 x 5 & 0.00 & 0.01 & 1.14 & 2.21 & 0.00 & 0.12 & 18.53  \\
\noalign{\smallskip}
20 x 6 & 0.03 & 0.11 & 1.05 & 1.92 & 0.01 & 0.24 & 15.63  \\
 \hline \noalign{\smallskip}
	Average: & 0.00 & 0.02 & 0.86  & 1.58 & 0.02 & 0.10 & 8.06 
 \\
	\noalign{\smallskip}\hline
\end{tabular}
\label{table:small-results}
\end{table}

Um fator importante a se considerar ao julgar a qualidade de soluções dos algoritmos é o tempo de execução. Neste trabalho, o tempo foi medido em segundos e suas médias apresentadas por grupos na Tabela \ref{table:time-small}.  Nela, o software CPLEX é executado com tempo médio t=3600(s), indicando que a solução ótima não foi atingida com certeza no tempo limite. Para as três heurísticas, o pior tempo médio foi alcançado pela heurística populacional (GA$\_$LS). Dentre as heurísticas de solução única, ILS$\_$RVND$\_$1 obteve o melhor tempo médio de execução.


\begin{table}
\centering
\caption{Runtime Average Analysis over small instances.}
\begin{tabular}{ccccc}
	\hline\noalign{\smallskip}
	& ILS$\_$RVND$\_$1 & ILS$\_$RVND$\_$2 & GA$\_$LS & CPLEX \\
	\cline{2-5}\noalign{\smallskip}
	N x K & Avg. & Avg. & Avg. & Avg. \\
	\hline
\noalign{\smallskip}
10 x  3 & 0.11 & 0.16 & 0.17 &  3575.10 \\
\noalign{\smallskip}
10 x  4 & 0.14 & 0.25 & 0.22  & 3620.62\\
\noalign{\smallskip}
10 x  5 & 0.17 & 0.37 & 0.27  & 3629.82\\
\noalign{\smallskip}
10 x  6 & 0.20 & 0.45 & 0.33  & 3634.85\\
\noalign{\smallskip}
15 x  3 & 0.33 & 0.30 & 0.53  & 3614.83\\
\noalign{\smallskip}
15 x  4 & 0.39 & 0.46 & 0.62  & 3632.21\\
\noalign{\smallskip}
15 x  5 & 0.47 & 0.71 & 0.74  & 3647.36\\
\noalign{\smallskip}
15 x  6 & 0.54 & 0.91 & 0.86  & 3649.92\\
\noalign{\smallskip}
20 x  3 & 0.79 & 0.51 & 1.25  & 3612.73\\
\noalign{\smallskip}
20 x  4 & 0.83 & 0.76 & 1.34 & 3615.70\\
\noalign{\smallskip}
20 x  5 & 0.99 & 1.11 & 1.61  & 3618.98\\
\noalign{\smallskip}
20 x  6 & 1.09 & 1.52 & 1.74  & 3621.38\\
 \hline \noalign{\smallskip}
	Average: & 0.51 & 0.63 & 0.81 & 3622.79
 \\
	\noalign{\smallskip}\hline
\end{tabular}
\label{table:time-small}
\end{table}


\subsection{Resultados em Instâncias Grandes}\label{large-instances-results}

Em instâncias grandes, os resultados para as heurísticas foram comparados entre si. As três heurísticas foram executadas cinco vezes em cada uma das 540 instâncias de grande porte. A qualidade das soluções encontradas é também avaliada pelo Average RPD(\%) pela Equação \ref{rpd} e plotadas na Figura \ref{graphics:large} com intervalos de à 95\% de confiança. Neste grupo de instâncias, é possível observar um distanciamento considerável do algoritmo ILS$\_$RNVD$\_$2 para os demais algoritmos. 

Pelo Teste de Kruskall-Wallis, o p-valor=$0.00 \leq 0.05$ obtido sustenta a hipótese alternativa de que pelo menos uma implementação é significativamente diferente das demais.
Além disso, não existem intervalos sobrepostos nos gráficos para $N \in \{50,80,100\}$, o que indica que todas os resultados são realmente estatisticamente diferentes.

Os algoritmos se comportam de forma semelhante à medida em que o número de clientes $N$ aumenta, e no gráfico geral, ao distanciar o intervalo algoritmo ILS$\_$RVND$\_$1 do eixo x, indica que há instâncias em que os demais algoritmos obtiveram melhores resultados.

\begin{figure}
\label{graphics:large}
\centering     %%% not \center
\makebox[\textwidth][c]{
\subfigure[Average RPD with $N = 50$]{\label{fig:a}\includegraphics[width=78mm]{Images/large-instances/avg rpd 50 jobs int}}
\subfigure[Average RPD with $N = 80$]{\label{fig:b}\includegraphics[width=78mm]{Images/large-instances/avg rpd 80 jobs int}} 
}
\makebox[\textwidth][c]{
\subfigure[Average RPD with $N = 100$]{\label{fig:c}\includegraphics[width=78mm]{Images/large-instances/avg rpd 100 jobs int}} 
\subfigure[General Average RPD]{\label{fig:d}\includegraphics[width=78mm]{Images/large-instances/avg rpd all algos}} 
}
\caption{Gráfico médio e intervalos de confiança com nível de confiança de 95\% para instâncias de grande porte.}
\end{figure}

Na Tabela \ref{table:large-results}, ao analisar os resultados pelos conjuntos de instâncias, é possível observar que a primeira heurística ILS$\_$RVND$\_$1 obteve destaque em cima das demais, seguido do Algoritmo Genético  GA$\_$LS e da segunda heurística ILS$\_$RVND$\_$2. Apenas em um conjunto de instâncias, '50-5', o primeiro obteve a média para o Best RPD(\%) inferior a média de melhor resultado do Algoritmo Genético.

\begin{table}
\centering
\caption{Best RPD and Avg. RPD analysis over large instances.}
\begin{tabular}{ccccccc}
	\hline\noalign{\smallskip}
	& \multicolumn{2}{c}{ILS$\_$RVND$\_$1} & \multicolumn{2}{c}{ILS$\_$RVND$\_$2} & \multicolumn{2}{c}{GA$\_$LS}\\
	\cline{2-7}\noalign{\smallskip}
	N x K & Best & Avg. & Best & Avg.  & Best & Avg. \\
	\hline
\noalign{\smallskip}
50 x  5 & 0.41 & 0.89 &12.02 & 13.91 & 0.21 & 1.48 \\
\noalign{\smallskip}
50 x  8 & 0.00 & 0.41 & 10.90 & 13.14 & 0.93 & 2.22 \\
\noalign{\smallskip}
50 x  10 & 0.00 & 0.31 & 10.11 & 11.86 & 1.15 & 2.38 \\
\noalign{\smallskip}
50 x  12 & 0.00 & 0.31 & 9.05  & 10.75 & 1.40 & 2.43 \\
\noalign{\smallskip}
80 x  5 & 0.71 & 1.63 & 14.52 & 15.80 & 0.89 & 2.40 \\
\noalign{\smallskip}
80 x  8 & 0.05 & 0.65 & 16.53 & 18.05 & 1.76 & 3.38 \\
\noalign{\smallskip}
80 x  10 & 0.00 & 0.59 & 16.13 & 17.63 & 2.19 & 3.43 \\
\noalign{\smallskip}
80 x  12 & 0.00 & 0.40 & 14.56 & 16.19 & 2.11 & 3.29 \\
\noalign{\smallskip}
100 x  5 & 0.61 & 1.24 & 14.63 & 15.95 & 0.91 & 2.44 \\
\noalign{\smallskip}
100 x  8 & 0.00 & 0.69 & 17.12 & 18.90 & 2.03 & 3.40 \\
\noalign{\smallskip}
100 x  10 & 0.01 & 0.46 & 16.86 & 18.56 & 2.24 & 3.57 \\
\noalign{\smallskip}
100 x  12 & 0.00 & 0.45 & 16.64 & 18.17 & 2.37 & 3.48 \\
 \hline \noalign{\smallskip}
	Average: & 0.15 & 0.67 & 14.09  & 15.74 & 1.52 & 2.83
 \\
	\noalign{\smallskip}\hline
\end{tabular}
\label{table:large-results}
\end{table}

Ao analisar o tempo de execução das três implementações em instâncias grandes, na Tabela \ref{table:time-large} é possível observar que em todos os grupos, o algoritmo ILS$\_$RVND$\_$2 foi executou com média mais rápida, seguido do algoritmo ILS$\_$RVND$\_$1 e então do Algoritmo Genético GA$\_$LS. Por se tratar de uma heurística populacional, o GA$\_$LS consome mais tempo para gerar e avaliar toda a população repetidas vezes. 
\begin{table}
\centering
\caption{Runtime Average Analysis over large instances.}
\begin{tabular}{cccc}
	\hline\noalign{\smallskip}
	& ILS$\_$RVND$\_$1 & ILS$\_$RVND$\_$2 & GA$\_$LS\\
	\cline{2-4}\noalign{\smallskip}
	N x K & Avg. & Avg. & Avg. \\
	\hline
\noalign{\smallskip}
50 x  5 & 17.57 & 8.48 & 35.41  \\
\noalign{\smallskip}
50 x  8 & 16.93 & 11.90 & 36.60  \\
\noalign{\smallskip}
50 x  10 & 16.32 & 14.44 & 36.55  \\
\noalign{\smallskip}
50 x  12 & 16.46 & 17.22 & 38.87   \\
\noalign{\smallskip}
80 x  5 & 68.03 & 28.37 & 180.42  \\
\noalign{\smallskip}
80 x  8 & 58.88 & 35.36 & 162.78  \\
\noalign{\smallskip}
80 x  10 & 55.00 & 40.32 & 154.89  \\
\noalign{\smallskip}
80 x  12 & 53.02 & 46.44 & 160.59  \\
\noalign{\smallskip}
100 x  5 & 136.08 & 51.34 & 415.69  \\
\noalign{\smallskip}
100 x  8 & 114.50 & 61.28 & 357.94 \\
\noalign{\smallskip}
100 x  10 & 103.80 & 68.83 & 340.52  \\
\noalign{\smallskip}
100 x  12 & 97.80 & 77.04 & 343.74  \\
 \hline \noalign{\smallskip}
	Average: & 62.87 & 38.42 & 188.67
 \\
	\noalign{\smallskip}\hline
\end{tabular}
\label{table:time-large}
\end{table}

Para a heurística ILS$\_$RVND$\_$2, a técnica de Aprimoramento Interno de Rota não obteve sucesso para instâncias grandes, e isso se dá pelo aprimoramento de vizinhanças externas às rotas não obtêr um número favorável de melhoras a assim acionar o aprimoramento interno. Isso não acontece na primeira heurística ILS$\_$RVND$\_$2, que aciona todas as vizinhanças internas e externas em ordem aleatória (RVND). Dessa forma, o tempo de médio de execução para a heurística ILS$\_$RVND$\_$1  é significativamente superior a da outra (ILS$\_$RVND$\_$2).




\section{Conclusões}\label{conclusions}

Neste trabalho foram realizados estudos para solucionar o problema integrado de agendamento de produção e entrega, com frota heterogênea de veículos e tarefas de diferentes capacidades. 

Por se tratar de um problema NP-Difícil, métodos convencionais são ineficientes para resolver o problema. Pelo conhecimento dos autores, até o atual momento havia sido abordada na literatura esta versão do problema integrado.

Foram propostos um modelo MILP, duas heurísticas Iterated Local Search com RVND e um Algoritmo Genético para o problema. As instâncias para esta nova abordagem foram geradas aqui, totalizando 1740 instâncias de pequeno e grande porte. A quantidade máxima de clientes considerados foi de 100 clientes.

Em instâncias pequenas, as heurísticas obtiveram melhores soluções do que o Solver CPLEX em um tempo muito inferior. O Solver CPLEX foi executado para instâncias de até 20 clientes.
A implementação básica de Iterated Local Search com RVND (ILS$\_$RVND$\_$1), no geral, se mostrou a mais eficiente quando comparadas com as demais e ao software CPLEX, em qualidade de solução e tempo de execução. 

Para trabalhos futuros, o objetivo é tratar esse problema em um ambiente com máquinas paralelas e tempo de preparação das máquinas.

\subsubsection*{Acknowledgments.}
The authors thanks the financial support of FAPEMIG, CAPES and CNPq, Brazilian research agencies.

\bibliographystyle{ieeetr}
\bibliography{Bibliography/papers.bib}


\end{document}